An R package for named capture regular expressions

| [[file:tests/testthat][tests]]    | [[https://travis-ci.org/tdhock/namedCapture][https://travis-ci.org/tdhock/namedCapture.png?branch=master]]                           |
| [[https://github.com/jimhester/covr][coverage]] | [[https://coveralls.io/github/tdhock/namedCapture?branch=master][https://coveralls.io/repos/tdhock/namedCapture/badge.svg?branch=master&service=github]] |

Since R-2.14 (released in 2011), the base functions =regexpr= and
=gregexpr= support named capture regular expressions via the excellent
Perl-Compatible Regular Expressions (PCRE) C library. However their
output is a bunch of integers and group names, which is not very
user-friendly. The namedCapture packages provides user-friendly
functions for extracting data from text using named capture regular
expressions. 

** Related work

- =regexec= and =regmatches= in base R implement extracting capture
  groups but the =regexec= man page indicates that perl=TRUE (and thus
  named capture) is not implemented.
- from R-3.4.0, =utils::strcapture= is an alternative to
  =namedCapture::str_match_named= (extract first match from each
  subject), but there is still no alternative for
  =namedCapture::str_match_all_named= (extract all matches from each
  subject).
- =stringr::str_match= implements extracting capture groups. But since
  it uses the [[https://github.com/gagolews/stringi][stringi]] package (an interface to the [[http://userguide.icu-project.org/strings/regexp][ICU]] library), [[https://github.com/hadley/stringr/pull/16][it
  does not support named capture]].
- [[https://github.com/MangoTheCat/rematch2][rematch2::re_match]], [[https://github.com/kevinushey/rex][rex::re_matches]], and [[https://github.com/qinwf/re2r][re2r::re2_match]] provide similar functionality
  to =namedCapture::str_match_named=. The main difference is that re2r
  uses the RE2 C++ library (worse case polynomial time complexity),
  but rematch2, rex, and namedCapture use base R (PCRE C library, exponential
  worst case time complexity).
- [[https://tidyr.tidyverse.org/reference/separate.html][tidyr::separate]] and [[https://tidyr.tidyverse.org/reference/extract.html][tidyr::extract]] provide similar functionality to
  =namedCapture::df_match_variable= (all input data.frame to extract
  from, and output data.frame). However there are a few differences:
  - named capture groups are supported in =df_match_variable= but not in =tidyr=.
  - namedCapture is much easier to install (it has no compiled code,
    and does not depend on any other packages).
  - A single call to =separate= or =extract= outputs new data columns
    from a single input data column, whereas a single call to
    =df_match_variable= can output new data columns from multiple
    input data columns.
  - regex is used in =separate= for the group separator, whereas regex
    is used in =df_match_variable= and =extract= for the entire text
    (including groups).
  - group names are specified using the =into= argument of =separate=
    and =extract=, whereas group names are specified using R argument
    names / capture group names in =df_match_variable=.
  - =type.convert(as.is=TRUE)= is always used to define types in
    =separate= and =extract=, whereas any function can be used to
    define types in =df_match_variable=.
- [[https://github.com/kevinushey/rex][rex]] provides functions (a domain specific language) for verbosely defining named capture regular expressions in R code. In rex 
  rex(capture(name = "fruit", pattern)) is the analog of list(fruit=pattern) namedCapture::*_variable -- both will generate a capture group named fruit.
- [[https://github.com/tdhock/revector][revector]] provides fast C code for a
  *vector* of named capture regular expressions (namedCapture and base
  R and only provide functions for a single regular expression).

| Package      | First match              | All matches             | library  | subject | pattern      | outputs     | named | types |
|--------------+--------------------------+-------------------------+----------+---------+--------------+-------------+-------+-------|
| base         | regexpr                  | gregexpr                | PCRE/TRE | chr     | chr          | mat/list    | yes   | no    |
| utils        | strcapture               | NA                      | PCRE/TRE | chr     | chr          | df          | no    | some  |
| namedCapture | str_match_named          | str_match_all_named     | PCRE     | chr     | chr          | mat/df/list | yes   | any   |
| namedCapture | str_match_variable       | str_match_all_variable  | PCRE     | chr     | verbose      | mat/df/list | yes   | any   |
| namedCapture | df_match_variable        | NA                      | PCRE     | df/dt   | verbose      | df/dt       | yes   | any   |
| rex          | re_matches(global=FALSE) | re_matches(global=TRUE) | PCRE     | chr     | verbose      | df          | yes   | no    |
| stringr      | str_match                | str_match_all           | ICU      | chr     | chr          | mat/list    | no    | no    |
| stringi      | stri_match               | stri_match_all          | ICU      | chr     | chr          | mat/list    | no    | no    |
| tidyr        | extract                  | NA                      | ICU      | df/dt   | chr          | df/dt       | no    | some  |
| rematch2     | re_match                 | re_match_all            | PCRE/TRE | chr     | chr          | tibble      | yes   | no    |
| re2r         | re2_match                | re2_match_all           | RE2      | chr     | chr/compiled | df/list     | yes   | no    |

Note in the comparison table above:
- library gives the underlying C library used.
- subject/pattern/output gives the support input/output types.
- the "named" column refers to named capture group support,
  which greatly helps to make a more readable regex pattern. The
  namedCapture package is the only one that provides output with
  names/rownames based on the "name" capture group.
- the "types" column refers to built-in support for converting capture
  groups from character to other types. (it is always possible to
  convert types afterwards)

** Installation

#+BEGIN_SRC R
install.packages("namedCapture")
##OR:
if(!require(devtools))install.packages("devtools")
devtools::install_github("tdhock/namedCapture")
#+END_SRC

** Usage overview

There are five main functions provided in namedCapture:

|                             | Extract first match  | Extract each match       |
| chr subject + two arguments | =str_match_named=    | =str_match_all_named=    |
| chr subject + variable args | =str_match_variable= | =str_match_all_variable= |
| df subject + variable args  | =df_match_variable=  | Not implemented          |

The function prefix indicates the type of the first argument, which
must contain the subject:
- =str_*= means a character vector -- each of these functions uses a
  single named capture regular expression to extract data from a
  character vector subject.
- =df_*= means a data.frame -- the [[#tidy-variable-argument-syntax-for-dataframedatatable][df_match_variable]] function uses a
  different named capture regular expression to extract data from each
  of several specified character column subjects. 
The function suffix indicates the type of the other arguments (after
the first):
- =*_named= means three arguments: subject, pattern, functions. The
  pattern should be a length-1 character vector that contains named
  capture groups, e.g. "(?<groupName1>subPattern1)"
- =*_variable= means a variable number of arguments which can be list,
  character, or function. Character strings are interpreted as regular
  expressions, which pasted together to obtain the final pattern to
  match to the subjects. Usually the specified character strings
  should NOT contain named capture groups, because a named capture
  group is generated automatically using R argument names, e.g. the
  argument groupName1="subPattern1" will generate the regex
  "(?<groupName1>subPattern1)". Each function is used to convert the
  group specified by the previous named R argument. Lists are parsed
  recursively, so can contain other lists, functions, and (named) character
  strings.

Vignettes:
- [[https://cran.r-project.org/web/packages/namedCapture/vignettes/Three_argument_syntax.html][Three argument syntax]] describes the most basic features of the
  =*_named= functions,
  including type conversion functions, and the =name= group for output
  with rownames or list names.
- [[https://cran.r-project.org/web/packages/namedCapture/vignettes/Variable_argument_syntax.html][Variable argument syntax]] describes the more advanced features of the
  =*_variable= functions.

** Comparison with rex

In this section we compare namedCapture verbose variable argument
syntax with the similar rex package. We have translated the rex log
parsing example to namedCapture syntax. There are two major
differences in syntax:
- namedCapture assumes the user knows regular expressions and can
  write them in R code; rex assumes the user knows its functions,
  which generate regex strings. E.g. the capture group "time",
  =none_of("]") %>% zero_or_more()= in rex gets translated to the
  regex string =[^]]*=. Thus rex code is a bit more verbose than
  namedCapture.
- Type conversion functions. In namedCapture they are specified on the
  same line as the capture group name/pattern, whereas in rex they are
  specified after the pattern, using mutate. rex could support inline
  type conversion by adding an argument to the =capture= function.

#+BEGIN_SRC R
  subject <- '198.214.42.14 - - [21/Jul/1995:14:31:46 -0400] "GET /images/ HTTP/1.0" 200 17688
  lahal.ksc.nasa.gov - - [24/Jul/1995:12:42:40 -0400] "GET /images/USA-logosmall.gif HTTP/1.0" 200 234
  199.171.112.23 - - [02/Jul/1995:02:30:34 -0400] "GET /images/KSC-logosmall.gif HTTP/1.0" 200 1204
  gate3.fmr.com - - [05/Jul/1995:13:51:39 -0400] "GET /shuttle/countdown/ HTTP/1.0" 200 3985
  curly02.slip.yorku.ca - - [10/Jul/1995:23:11:49 -0400] "GET /shuttle/missions/sts-70/sts-70-patch-small.gif HTTP/1.0" 200 5026
  boson.epita.fr - - [15/Jul/1995:11:27:49 -0400] "GET /shuttle/missions/sts-71/movies/sts-71-mir-dock.mpg HTTP/1.0" 200 946425
  134.153.50.9 - - [13/Jul/1995:11:02:50 -0400] "GET /icons/text.xbm HTTP/1.0" 200 527
  port00.ventura.rain.org - - [23/Jul/1995:09:11:06 -0400] "GET /shuttle/countdown/ HTTP/1.0" 200 4324
  128.159.145.91 - - [14/Jul/1995:10:38:04 -0400] "GET /statistics/images/getstats_big.gif HTTP/1.0" 200 6777
  slo.eei.upmc.edu - - [25/Jul/1995:09:33:01 -0400] "GET /images/KSC-logosmall.gif HTTP/1.0" 200 1204
  206.13.med.umich.edu - - [14/Jul/1995:09:11:28 -0400] "GET /shuttle/resources/orbiters/challenger-logo.gif HTTP/1.0" 200 4179'
  subject.vec <- strsplit(subject, split="\n")[[1]]

  result.list <- list()

  ## namedCapture 10 lines
  result.list$namedCapture <- namedCapture::str_match_variable(
    subject.vec,
    "\\[",
    time="[^]]*", function(x)as.POSIXct(x, format="%d/%b/%Y:%H:%M:%S %z"),
    "\\]",
    ' "GET ',
    "(?:",#maybe
    "[^[:space:]]+[.]",
    filetype='[^[:space:].?"]+', tolower,
    ")?")

  ## rex 17 lines
  library(rex)
  library(dplyr)
  result.list$rex <- re_matches(
    subject.vec,
    rex(
      "[",
      capture(name = "time",
	      none_of("]") %>% zero_or_more()),
      "]",
      space, double_quote, "GET", space,
      maybe(
	non_spaces, ".",
	capture(name = 'filetype',
		none_of(space, ".", "?", double_quote) %>% one_or_more())
      )
    )
  ) %>%
    mutate(filetype = tolower(filetype),
	   time = as.POSIXct(time, format="%d/%b/%Y:%H:%M:%S %z"))

  with(result.list, identical(rex, namedCapture))
#+END_SRC

** Comparison with tidyr

Below I show comparisons between =namedCapture::df_match_variable= and
its closest cousin in the R package universe, =tidyr::extract=. The
two packages can be used to compute the same result, but the
code/syntax is different.

*** Longer more readable syntax 

In this first comparison we use a syntax with each group name on the
same line as its pattern. Here are some observations from the
comparison:
- The =namedCapture= code is shorter. The =tidyr= code is longer
  mostly because the for loop that you see below for =tidyr= is hidden
  inside the definition of =namedCapture::df_match_variable=.
- Converting extracted character groups to numeric column types is
  specified via the =convert= argument of =tidyr::extract=, which uses
  =utils::type.convert=. Because =type.convert= does not know how to
  convert strings like =111,000= to integer, we first need to use
  =remove.commas= to create a new data.frame to use as input to
  =tidyr::extract=. In contrast =namedCapture= supports arbitrary
  group-specific type conversion functions; we specify =to.int= on the
  same line as the corresponding name/pattern for the
  chromStart/chromEnd groups.

#+BEGIN_SRC R
  ## First define data.
  (sacct.df <- data.frame(
    position=c(
      "chr10:213,054,000-213,055,000",
      "chrM:111,000-222,000",
      "this will not match",
      NA, # neither will this.
      "chr1:110-111 chr2:220-222"), # two possible matches.
    JobID=c(
      "13937810_25",
      "13937810_25.batch",
      "13937810_25.extern",
      "14022192_[1-3]",
      "14022204_[4]"),
    stringsAsFactors=FALSE))
  remove.commas <- function(x)gsub(",", "", x)
  result.list <- list()

  ## namedCapture: 29 lines of code.
  range.list <- list(
    "\\[",
    task1="[0-9]+", as.integer,
    "(?:-",#begin optional end of range.
    taskN="[0-9]+", as.integer,
    ")?", #end is optional.
    "\\]")
  task.list <- list(
    "(?:",#begin alternate
    task="[0-9]+", as.integer,
    "|",#either one task(above) or range(below)
    range.list,
    ")")#end alternate
  to.int <- function(x)as.integer(remove.commas(x))
  (result.list$namedCapture <- namedCapture::df_match_variable(
    sacct.df,
    JobID=list(
      job="[0-9]+", as.integer,
      "_",
      task.list,
      "(?:[.]",
      type=".*",
      ")?"),
    position=list(
      chrom="chr.*?",
      ":",
      chromStart=".*?", to.int,
      "-",
      chromEnd="[0-9,]*", to.int)))

  ## tidyr: 46 lines of code.
  range.vec <- c(
    "\\[",
    task1="[0-9]+", 
    "(?:-",#begin optional end of range.
    taskN="[0-9]+", 
    ")?", #end is optional.
    "\\]")
  task.vec <- c(
    "(?:",#begin alternate
    task="[0-9]+", 
    "|",#either one task(above) or range(below)
    range.vec,
    ")")#end alternate
  regex.list <- list(
    JobID=c(
      job="[0-9]+", 
      "_",
      task.vec,
      "(?:[.]",
      type=".*",
      ")?"),
    position=c(
      chrom="chr.*?",
      ":",
      chromStart=".*?",
      "-",
      chromEnd="[0-9,]*"))
  tidyr.input <- transform(
    sacct.df,
    position=remove.commas(position))
  tidyr.df.list <- list(sacct.df)
  for(col.name in names(regex.list)){
    regex.vec <- regex.list[[col.name]]
    is.group <- names(regex.vec)!=""
    format.vec <- ifelse(is.group, "(%s)", "%s")
    group.vec <- sprintf(format.vec, regex.vec)
    regex <- paste(group.vec, collapse="")
    group.names <- names(regex.vec)[is.group]
    result <- tidyr::extract(
      tidyr.input, col.name, group.names, regex, convert=TRUE)
    to.save <- result[, group.names, drop=FALSE]
    names(to.save) <- paste0(col.name, ".", group.names)
    tidyr.df.list[[col.name]] <- to.save
  }
  names(tidyr.df.list) <- NULL
  result.list$tidyr <- do.call(cbind, tidyr.df.list)

  ## Make sure the results are the same.
  t(sapply(result.list, names))
  t(sapply(result.list, sapply, class))
  result.list$tidyr$JobID.type <- ifelse(
    is.na(result.list$tidyr$JobID.type),
    "",
    result.list$tidyr$JobID.type)
  with(result.list, identical(tidyr, namedCapture))

#+END_SRC

*** Shorter less readable syntax

This second comparison uses a syntax with the entire regex on one
line. In my opinion this syntax makes the regular expressions more
difficult to read/understand. Complicated regular expressions like the
one used for matching the JobID column are not
maintainable/understandable at all using this syntax.

#+BEGIN_SRC R
  ## First define data.
  (sacct.df <- data.frame(
    position=c(
      "chr10:213,054,000-213,055,000",
      "chrM:111,000-222,000",
      "this will not match",
      NA, # neither will this.
      "chr1:110-111 chr2:220-222"), # two possible matches.
    JobID=c(
      "13937810_25",
      "13937810_25.batch",
      "13937810_25.extern",
      "14022192_[1-3]",
      "14022204_[4]"),
    stringsAsFactors=FALSE))
  result.list <- list()

  ## tidyr alternate (13 lines total)
  e <- function(col.name, group.names, pattern){
    result <- tidyr::extract(
      sacct.df, col.name, group.names, pattern, convert=TRUE)
    to.save <- result[, group.names, drop=FALSE]
    names(to.save) <- paste0(col.name, ".", group.names)
    to.save
  }
  result.list$tidyr <- do.call(cbind, list(
    sacct.df,
    e("JobID", c("job", "task", "task1", "taskN", "type"),
      "([0-9]+)_(?:([0-9]+)|\\[([0-9]+)(?:-([0-9]+))?\\])(?:[.](.*))?"),
    e("position", c("chrom", "chromStart", "chromEnd"),
      "(chr.*?):(.*?)-([0-9,]*)")))

  ## namedCapture alternate (7 lines total)
  (result.list$namedCapture <- namedCapture::df_match_variable(
    sacct.df,
    JobID="(?<job>[0-9]+)_(?:(?<task>[0-9]+)|\\[(?<task1>[0-9]+)(?:-(?<taskN>[0-9]+))?\\])(?:[.](?<type>.*))?",
    position="(?<chrom>chr.*?):(?<chromStart>.*?)-(?<chromEnd>[0-9,]*)"))
  for(N in names(result.list$namedCapture)){
    result.list$namedCapture[[N]] <- type.convert(result.list$namedCapture[[N]], as.is=TRUE)
  }

  ## Make sure the results are the same.
  t(sapply(result.list, names))
  t(sapply(result.list, sapply, class))
  result.list$tidyr$JobID.type <- ifelse(
    is.na(result.list$tidyr$JobID.type),
    "",
    result.list$tidyr$JobID.type)
  with(result.list, identical(tidyr, namedCapture))
#+END_SRC

** Named capture regular expressions tutorial

For a more complete introduction to named capture regular expressions
in R and Python, see https://github.com/tdhock/regex-tutorial
