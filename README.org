An R package for named capture regular expressions

| [[file:tests/testthat][tests]]    | [[https://travis-ci.org/tdhock/namedCapture][https://travis-ci.org/tdhock/namedCapture.png?branch=master]]                           |
| [[https://github.com/jimhester/covr][coverage]] | [[https://coveralls.io/github/tdhock/namedCapture?branch=master][https://coveralls.io/repos/tdhock/namedCapture/badge.svg?branch=master&service=github]] |

Since R-2.14 (released in 2011), the base functions =regexpr= and
=gregexpr= support named capture regular expressions via the excellent
Perl-Compatible Regular Expressions (PCRE) C library. However their
output is a bunch of integers and group names, which is not very
user-friendly. The namedCapture packages provides user-friendly
functions for extracting data from text using named capture regular
expressions. 

** Related work

- =regexec= and =regmatches= in base R implement extracting capture
  groups but the =regexec= man page indicates that perl=TRUE (and thus
  named capture) is not implemented.
- from R-3.4.0, =utils::strcapture= is an alternative to
  =namedCapture::str_match_named= (extract first match from each
  subject), but there is still no alternative for
  =namedCapture::str_match_all_named= (extract all matches from each
  subject).
- =stringr::str_match= implements extracting capture groups. But since
  it uses the [[https://github.com/gagolews/stringi][stringi]] package (an interface to the [[http://userguide.icu-project.org/strings/regexp][ICU]] library), [[https://github.com/hadley/stringr/pull/16][it
  does not support named capture]].
- [[https://github.com/MangoTheCat/rematch2][rematch2::re_match]], [[https://github.com/kevinushey/rex][rex::re_matches]], and [[https://github.com/qinwf/re2r][re2r::re2_match]] provide similar functionality
  to =namedCapture::str_match_named=. The main difference is that re2r
  uses the RE2 C++ library (worse case polynomial time complexity),
  but rematch2, rex, and namedCapture use base R (PCRE C library, exponential
  worst case time complexity).
- [[https://tidyr.tidyverse.org/reference/separate.html][tidyr::separate]] and [[https://tidyr.tidyverse.org/reference/extract.html][tidyr::extract]] provide similar functionality to
  =namedCapture::df_match_variable= (all input data.frame to extract
  from, and output data.frame). However there are a few differences:
  - named capture groups are supported in =df_match_variable= but not in =tidyr=.
  - namedCapture is much easier to install (it has no compiled code,
    and does not depend on any other packages).
  - A single call to =separate= or =extract= outputs new data columns
    from a single input data column, whereas a single call to
    =df_match_variable= can output new data columns from multiple
    input data columns.
  - regex is used in =separate= for the group separator, whereas regex
    is used in =df_match_variable= and =extract= for the entire text
    (including groups).
  - group names are specified using the =into= argument of =separate=
    and =extract=, whereas group names are specified using R argument
    names / capture group names in =df_match_variable=.
  - =type.convert(as.is=TRUE)= is always used to define types in
    =separate= and =extract=, whereas any function can be used to
    define types in =df_match_variable=.
- [[https://github.com/kevinushey/rex][rex]] provides functions (a domain specific language) for verbosely defining named capture regular expressions in R code. In rex 
  rex(capture(name = "fruit", pattern)) is the analog of list(fruit=pattern) namedCapture::*_variable -- both will generate a capture group named fruit.
- [[https://github.com/tdhock/revector][revector]] provides fast C code for a
  *vector* of named capture regular expressions (namedCapture and base
  R and only provide functions for a single regular expression).

| Package      | First match              | All matches             | library  | subject | pattern      | outputs     | named | types |
|--------------+--------------------------+-------------------------+----------+---------+--------------+-------------+-------+-------|
| base         | regexpr                  | gregexpr                | PCRE/TRE | chr     | chr          | mat/list    | yes   | no    |
| utils        | strcapture               | NA                      | PCRE/TRE | chr     | chr          | df          | no    | some  |
| namedCapture | str_match_named          | str_match_all_named     | PCRE     | chr     | chr          | mat/df/list | yes   | any   |
| namedCapture | str_match_variable       | str_match_all_variable  | PCRE     | chr     | verbose      | mat/df/list | yes   | any   |
| namedCapture | df_match_variable        | NA                      | PCRE     | df/dt   | verbose      | df/dt       | yes   | any   |
| rex          | re_matches(global=FALSE) | re_matches(global=TRUE) | PCRE     | chr     | verbose      | df          | yes   | no    |
| stringr      | str_match                | str_match_all           | ICU      | chr     | chr          | mat/list    | no    | no    |
| stringi      | stri_match               | stri_match_all          | ICU      | chr     | chr          | mat/list    | no    | no    |
| tidyr        | extract                  | NA                      | ICU      | df/dt   | chr          | df/dt       | no    | some  |
| rematch2     | re_match                 | re_match_all            | PCRE/TRE | chr     | chr          | tibble      | yes   | no    |
| re2r         | re2_match                | re2_match_all           | RE2      | chr     | chr/compiled | df/list     | yes   | no    |

Note in the comparison table above:
- library gives the underlying C library used.
- subject/pattern/output gives the support input/output types.
- the "named" column refers to named capture group support,
  which greatly helps to make a more readable regex pattern. The
  namedCapture package is the only one that provides output with
  names/rownames based on the "name" capture group.
- the "types" column refers to built-in support for converting capture
  groups from character to other types. (it is always possible to
  convert types afterwards)

** Installation

#+BEGIN_SRC R
if(!require(devtools))install.packages("devtools")
devtools::install_github("tdhock/namedCapture")
#+END_SRC

** Usage examples

There are five main functions provided in namedCapture:

|                             | Extract first match  | Extract each match       |
| chr subject + two arguments | =str_match_named=    | =str_match_all_named=    |
| chr subject + variable args | =str_match_variable= | =str_match_all_variable= |
| df subject + variable args  | =df_match_variable=  | Not implemented          |

The function prefix indicates the type of the first argument, which
must contain the subject:
- =str_*= means a character vector -- each of these functions uses a
  single named capture regular expression to extract data from a
  character vector subject.
- =df_*= means a data.frame -- the [[#tidy-variable-argument-syntax-for-dataframedatatable][df_match_variable]] function uses a
  different named capture regular expression to extract data from each
  of several specified character column subjects. 
The function suffix indicates the type of the other arguments (after
the first):
- =*_named= means three arguments: subject, pattern, functions. The
  pattern should be a length-1 character vector that contains named
  capture groups, e.g. "(?<groupName1>subPattern1)"
- =*_variable= means a variable number of arguments which can be list,
  character, or function. Character strings are interpreted as regular
  expressions, which pasted together to obtain the final pattern to
  match to the subjects. Usually the specified character strings
  should NOT contain named capture groups, because a named capture
  group is generated automatically using R argument names, e.g. the
  argument groupName1="subPattern1" will generate the regex
  "(?<groupName1>subPattern1)". Each function is used to convert the
  group specified by the previous named R argument. Lists are parsed
  recursively, so can contain other lists, functions, and (named) character
  strings.

*** Three argument syntax

The functions on the first row take exactly three arguments:
- =subject= is the character vector from which we want to extract
  tabular data.
- =pattern= is the (character scalar) regular expression with named
  capture groups used for extraction.
- =fun.list= is a list with names that correspond to capture groups,
  and values are functions used to convert the extracted character
  data to other (typically numeric) types.

#+BEGIN_SRC R
  library(namedCapture)
  chr.pos.vec <- c(
    "chr10:213,054,000-213,055,000",
    "chrM:111,000-222,000",
    "this will not match",
    NA, # neither will this.
    "chr1:110-111 chr2:220-222") # two possible matches.
  chr.pos.pattern <- paste0(
    "(?<chrom>chr.*?)",
    ":",
    "(?<chromStart>.*?)",
    "-",
    "(?<chromEnd>[0-9,]*)")
  ## Specifying a list of conversion functions means that str_match_*
  ## should convert the matched groups from character to whatever is
  ## returned by those functions.
  keep.digits <- function(x)as.integer(gsub("[^0-9]", "", x))
  conversion.list <- list(chromStart=keep.digits, chromEnd=keep.digits)
  (match.df <- str_match_named(chr.pos.vec, chr.pos.pattern, conversion.list))
  str(match.df)

  ## Use str_match_all_named to get ALL matches in each subject (not
  ## just the first match).
  str_match_all_named(chr.pos.vec, chr.pos.pattern, conversion.list)
#+END_SRC

Running the =str_match_named= code above yields the following. Note
how the resulting data.frame contains one row for each subject, and
one column for each named capture group defined in the regular
expression pattern. Types are defined by the specified conversion
functions; missing values indicate missing subjects or no match.

#+BEGIN_SRC R-transcript
> (match.df <- str_match_named(chr.pos.vec, chr.pos.pattern, conversion.list))
  chrom chromStart  chromEnd
1 chr10  213054000 213055000
2  chrM     111000    222000
3  <NA>         NA        NA
4  <NA>         NA        NA
5  chr1        110       111
> str(match.df)
'data.frame':	5 obs. of  3 variables:
 $ chrom     : chr  "chr10" "chrM" NA NA ...
 $ chromStart: int  213054000 111000 NA NA 110
 $ chromEnd  : int  213055000 222000 NA NA 111
> 
#+END_SRC

As shown below, running the =str_match_all_named= code extracts all
matches from each subject. The result is a list with one element for
each subject. Each list element is a data.frame with one row for each
match.

#+BEGIN_SRC R-transcript
> str_match_all_named(chr.pos.vec, chr.pos.pattern, conversion.list)
[[1]]
  chrom chromStart  chromEnd
1 chr10  213054000 213055000

[[2]]
  chrom chromStart chromEnd
1  chrM     111000   222000

[[3]]
data frame with 0 columns and 0 rows

[[4]]
data frame with 0 columns and 0 rows

[[5]]
  chrom chromStart chromEnd
1  chr1        110      111
2  chr2        220      222

> 
#+END_SRC

*** Variable argument syntax for character vector subjects

The namedCapture package also provides =str_match*variable= functions
which take a variable number of arguments and allow for a shorter,
less repetitive, and thus more user-friendly syntax:
- The first argument must be the subject character vector.
- The other arguments must be patterns (character strings) or
  functions.
- If a pattern is named, we use the argument name in R for the capture
  group name in the regex.
- All patterns are pasted together in the order that they appear in
  the argument list.
- Each function is used to convert the text extracted by the previous
  named pattern/group. 

#+BEGIN_SRC R
  str_match_variable(
    chr.pos.vec, 
    chrom="chr.*?",
    ":",
    chromStart=".*?", keep.digits,
    "-",
    chromEnd="[0-9,]*", keep.digits)
  str_match_all_variable(
    chr.pos.vec, 
    chrom="chr.*?",
    ":",
    chromStart=".*?", keep.digits,
    "-",
    chromEnd="[0-9,]*", keep.digits)
#+END_SRC

Note in the code above how the group name, regex pattern, and
corresponding type conversion function are all on the same line --
this is encouraged in order to clarify/simplify the definition of
complex regular expressions.

The =str_match_variable= code below yields the same result as the
=str_match_named= code in the previous section: a data.frame with one
row for each subject, and one column for each named capture group.

#+BEGIN_SRC R-transcript
> str_match_variable(
+   chr.pos.vec, 
+   chrom="chr.*?",
+   ":",
+   chromStart=".*?", keep.digits,
+   "-",
+   chromEnd="[0-9,]*", keep.digits)
  chrom chromStart  chromEnd
1 chr10  213054000 213055000
2  chrM     111000    222000
3  <NA>         NA        NA
4  <NA>         NA        NA
5  chr1        110       111
> 
#+END_SRC

The =str_match_all_variable= code below yields a data.frame with one
row for each match in the subject, and one column for each named
capture group. Note that multiple elements in the subject are treated
as separate lines -- internally paste(,collapse="\n") is called to
create a length-1 character vector which is used as the subject in
=str_match_all_named=. This is for the common case of doing readLines
and then extracting all matches of a certain regex in that file. 

#+BEGIN_SRC R-transcript
> str_match_all_variable(
+   chr.pos.vec, 
+   chrom="chr.*?",
+   ":",
+   chromStart=".*?", keep.digits,
+   "-",
+   chromEnd="[0-9,]*", keep.digits)
  chrom chromStart  chromEnd
1 chr10  213054000 213055000
2  chrM     111000    222000
3  chr1        110       111
4  chr2        220       222
> 
#+END_SRC

Finally, sometimes it is simpler/clearer to define complicated
patterns in terms of previously defined sub-patterns. Therefore the
*_variable functions also accept lists as arguments. (which are parsed
recursively) For example, consider the following code block:

#+BEGIN_SRC R
  subject.vec <- c(
    "13937810_25",
    "13937810_25.batch",
    "13937810_25.extern",
    "14022192_[1-3]",
    "14022204_[4]")
  ## range.pattern matches "[4]" or "[1-3]"
  range.pattern <- list(
    "[[]",
    task1="[0-9]+", as.integer,
    "(?:-",#begin optional end of range.
    taskN="[0-9]+", as.integer,
    ")?", #end is optional.
    "[]]")
  ## task.pattern matches "25" or range.pattern.
  task.pattern <- list(
    "(?:",#begin alternate
    task="[0-9]+", as.integer,
    "|",#either one task(above) or range(below)
    range.pattern,
    ")")#end alternate
  (task.dt <- str_match_variable(
    subject.vec,
    job="[0-9]+", as.integer,
    "_",
    task.pattern,
    "(?:[.]",
    type=".*",
    ")?"))
#+END_SRC

The code block starts by defining a sub-pattern which matches =[4]= or
=[1-3]=, and saving it in a variable called =range.pattern=. It is
then used to define a second sub-pattern called =task.pattern= which
matches the above, and alternately matches digits without square
brackets, e.g. =25=. Then finally =task.pattern= is used to
clarify/simplify the call to =str_match_variable=, which yields the
output below.

#+BEGIN_SRC R-transcript
> (task.dt <- str_match_variable(
+   subject.vec,
+   job="[0-9]+", as.integer,
+   "_",
+   task.pattern,
+   "(?:[.]",
+   type=".*",
+   ")?"))
       job task task1 taskN   type
1 13937810   25    NA    NA       
2 13937810   25    NA    NA  batch
3 13937810   25    NA    NA extern
4 14022192   NA     1     3       
5 14022204   NA     4    NA       
> 
#+END_SRC

*** Extract all patterns from a file

In this section we demonstrate how to use =str_match_all_variable= to
extract data.frames from a loosely structured text file. 

#+BEGIN_SRC R
  trackDb.txt.gz <- system.file("extdata", "trackDb.txt.gz", package="namedCapture")
  trackDb.vec <- readLines(trackDb.txt.gz)
#+END_SRC

Some representative lines from that file are shown below.

#+BEGIN_SRC R-transcript
> cat(trackDb.vec[78:107], sep="\n")
track peaks_summary
type bigBed 5
shortLabel _model_peaks_summary
longLabel Regions with a peak in at least one sample
visibility pack
itemRgb off
spectrum on
bigDataUrl http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/peaks_summary.bigBed


 track bcell_McGill0091
 parent bcell
 container multiWig
 type bigWig
 shortLabel bcell_McGill0091
 longLabel bcell | McGill0091
 graphType points
 aggregate transparentOverlay
 showSubtrackColorOnUi on
 maxHeightPixels 25:12:8
 visibility full
 autoScale on

  track bcell_McGill0091Coverage
  bigDataUrl http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/coverage.bigWig
  shortLabel bcell_McGill0091Coverage
  longLabel bcell | McGill0091 | Coverage
  parent bcell_McGill0091
  type bigWig
  color 141,211,199
> 
#+END_SRC

Each block of text begins with "track" and includes several lines of
data before the block ends with two consecutive newlines. That pattern
is coded below using a regex:

#+BEGIN_SRC R
  fields.df <- namedCapture::str_match_all_variable(
    trackDb.vec,
    "track ",
    name="\\S+",
    fields="(?:\n[^\n]+)*",
    "\n")
#+END_SRC

The code above creates a data frame with one row for each track block,
with rownames given by the track line (because of the capture group
named name), and one fields column which is a string with the rest of
the data in that block.

#+BEGIN_SRC R-transcript
> head(fields.df)
                       fields                                                                                                      
bcell                  "\nsuperTrack on show\nshortLabel bcell\nlongLabel bcell ChIP-seq samples"                                  
kidneyCancer           "\nsuperTrack on show\nshortLabel kidneyCancer\nlongLabel kidneyCancer ChIP-seq samples"                    
kidney                 "\nsuperTrack on show\nshortLabel kidney\nlongLabel kidney ChIP-seq samples"                                
leukemiaCD19CD10BCells "\nsuperTrack on show\nshortLabel leukemiaCD19CD10BCells\nlongLabel leukemiaCD19CD10BCells ChIP-seq samples"
monocyte               "\nsuperTrack on show\nshortLabel monocyte\nlongLabel monocyte ChIP-seq samples"                            
skeletalMuscleCtrl     "\nsuperTrack on show\nshortLabel skeletalMuscleCtrl\nlongLabel skeletalMuscleCtrl ChIP-seq samples"        
> 
#+END_SRC

Each block has a variable number of lines/fields. Each line starts
with a field name, followed by a space, followed by the field
value. That regex is coded below:

#+BEGIN_SRC R
  fields.list <- namedCapture::str_match_all_named(
    fields.df[, "fields"], paste0(
      "\\s+",
      "(?<name>.*?)",
      " ",
      "(?<value>[^\n]+)"))
#+END_SRC

The result is a list of data frames. 

#+BEGIN_SRC R-transcript
> fields.list[12:14]
$peaks_summary
           value                                                                  
type       "bigBed 5"                                                             
shortLabel "_model_peaks_summary"                                                 
longLabel  "Regions with a peak in at least one sample"                           
visibility "pack"                                                                 
itemRgb    "off"                                                                  
spectrum   "on"                                                                   
bigDataUrl "http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/peaks_summary.bigBed"

$bcell_McGill0091
                      value               
parent                "bcell"             
container             "multiWig"          
type                  "bigWig"            
shortLabel            "bcell_McGill0091"  
longLabel             "bcell | McGill0091"
graphType             "points"            
aggregate             "transparentOverlay"
showSubtrackColorOnUi "on"                
maxHeightPixels       "25:12:8"           
visibility            "full"              
autoScale             "on"                

$bcell_McGill0091Coverage
           value                                                                                      
bigDataUrl "http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/coverage.bigWig"
shortLabel "bcell_McGill0091Coverage"                                                                 
longLabel  "bcell | McGill0091 | Coverage"                                                            
parent     "bcell_McGill0091"                                                                         
type       "bigWig"                                                                                   
color      "141,211,199"                                                                              

> 
#+END_SRC

There is a list element for each block, named by track. Each list
element is a data frame with one row per field defined in that
block (rownames are field names). The names/rownames make it easy
to write R code that selects individual elements by name, e.g.

#+BEGIN_SRC R-transcript
> fields.list$bcell_McGill0091Coverage["bigDataUrl",]
[1] "http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/coverage.bigWig"
> fields.list$monocyte_McGill0001Peaks["color",]
[1] "0,0,0"
> has.bigDataUrl <- sapply(fields.list, function(m)"bigDataUrl" %in% rownames(m))
> bigDataUrl.list <- fields.list[has.bigDataUrl]
> length(bigDataUrl.list)
[1] 78
> length(fields.list)
[1] 123
> 
#+END_SRC

So there are 78 tracks which define the bigDataUrl field, out of
123 total tracks.

In the example above we extracted all fields from all tracks (using
two regexes, one for the track, one for the field). In the example
below we extract only the bigDataUrl field for each track, and split
sample names into separate columns (using a single regex for the
track). It also demonstrates how to use nested named capture groups
(via named lists which contain named regex strings).

#+BEGIN_SRC R
  name.pattern <- list(
    cellType=".*?",
    "_",
    sampleName=list(
      "McGill",
      sampleID="[0-9]+", as.integer),
    dataType="Coverage|Peaks",
    "|",
    "[^\n]+")
  match.df <- namedCapture::str_match_all_variable(
    trackDb.vec,
    "track ",
    name=name.pattern,
    "(?:\n[^\n]+)*",
    "\\s+bigDataUrl ",
    bigDataUrl="[^\n]+")
#+END_SRC

#+BEGIN_SRC R-transcript
> head(match.df)
                         cellType sampleName sampleID dataType
all_labels                                         NA         
problems                                           NA         
jointProblems                                      NA         
peaks_summary                                      NA         
bcell_McGill0091Coverage    bcell McGill0091       91 Coverage
bcell_McGill0091Peaks       bcell McGill0091       91    Peaks
                                                                                                           bigDataUrl
all_labels                                         http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/all_labels.bigBed
problems                                             http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/problems.bigBed
jointProblems                                   http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/jointProblems.bigBed
peaks_summary                                   http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/peaks_summary.bigBed
bcell_McGill0091Coverage    http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/coverage.bigWig
bcell_McGill0091Peaks    http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/joint_peaks.bigWig
> 
#+END_SRC

Exercise for the reader: modify the above regex in order to capture
three additional columns (red, green, blue) from the color field.

*** Tidy variable argument syntax for data.frame/data.table

We also provide =namedCapture::df_match_variable= which extracts text
from several columns of a data.frame, using a different named capture
regular expression for each column.
- It requires a data.frame as the first argument.
- It takes a variable number of other arguments. (all of which must be
  named) For each other argument we call =str_match_variable= on one
  column of the input data.frame.
- Each argument name specifies a column of the data.frame which will
  be used as the subject in =str_match_variable=.
- Each argument value specifies a pattern to be used with
  =str_match_variable=. (in list/character/function format as
  explained in the previous section)
- The return value is a data.frame with the same number of rows as the
  input, but with an additional column for each named capture
  group. New columns are named using the convention
  =oldColumnName.groupName=.
- This is a "tidy" function that can be used in a [[https://r4ds.had.co.nz/pipes.html][pipe]].
This function can greatly simplify the code required to create numeric
data columns from character data columns. For example consider the
following data which was output from the [[https://slurm.schedmd.com/sacct.html][sacct]] program.

#+BEGIN_SRC R-transcript
   Elapsed              JobID
1 07:04:42        13937810_25
2 07:04:42  13937810_25.batch
3 07:04:49 13937810_25.extern
4 00:00:00     14022192_[1-3]
5 00:00:00       14022204_[4]
#+END_SRC

Say we want to filter by the total Elapsed time (which is reported as
hours:minutes:seconds), and base job id (which is the number before
the underscore in the JobID column). We could start by converting
those character columns to integers via:

#+BEGIN_SRC R-transcript
> (task.df <- df_match_variable(
+   sacct.df,
+   JobID=list(
+     job="[0-9]+", as.integer,
+     "_",
+     task.pattern,
+     "(?:[.]",
+     type=".*",
+     ")?"),
+   Elapsed=list(
+     hours="[0-9]+", as.integer,
+     ":",
+     minutes="[0-9]+", as.integer,
+     ":",
+     seconds="[0-9]+", as.integer)))
   Elapsed              JobID JobID.job JobID.task JobID.task1 JobID.taskN
1 07:04:42        13937810_25  13937810         25          NA          NA
2 07:04:42  13937810_25.batch  13937810         25          NA          NA
3 07:04:49 13937810_25.extern  13937810         25          NA          NA
4 00:00:00     14022192_[1-3]  14022192         NA           1           3
5 00:00:00       14022204_[4]  14022204         NA           4          NA
  JobID.type Elapsed.hours Elapsed.minutes Elapsed.seconds
1                        7               4              42
2      batch             7               4              42
3     extern             7               4              49
4                        0               0               0
5                        0               0               0
> 
#+END_SRC

We could then create a minutes column and filter on that:

#+BEGIN_SRC R-transcript
> library(dplyr)
> task.df %>%
+   transform(minutes=Elapsed.hours*60+Elapsed.minutes+Elapsed.seconds/60) %>%
+   filter(100 < minutes)
   Elapsed              JobID JobID.job JobID.task JobID.task1 JobID.taskN
1 07:04:42        13937810_25  13937810         25          NA          NA
2 07:04:42  13937810_25.batch  13937810         25          NA          NA
3 07:04:49 13937810_25.extern  13937810         25          NA          NA
  JobID.type Elapsed.hours Elapsed.minutes Elapsed.seconds  minutes
1                        7               4              42 424.7000
2      batch             7               4              42 424.7000
3     extern             7               4              49 424.8167
> 
#+END_SRC

Note that =df_match_variable= also works with data.tables:

#+BEGIN_SRC R-transcript
> library(data.table)
> (sacct.dt <- data.table(
+   Elapsed = c(
+     "07:04:42", "07:04:42", "07:04:49",
+     "00:00:00", "00:00:00"),
+   JobID=c(
+     "13937810_25",
+     "13937810_25.batch",
+     "13937810_25.extern",
+     "14022192_[1-3]",
+     "14022204_[4]")))
    Elapsed              JobID
1: 07:04:42        13937810_25
2: 07:04:42  13937810_25.batch
3: 07:04:49 13937810_25.extern
4: 00:00:00     14022192_[1-3]
5: 00:00:00       14022204_[4]
> (task.dt <- df_match_variable(
+   sacct.dt,
+   JobID=list(
+     job="[0-9]+", as.integer,
+     "_",
+     task.pattern,
+     "(?:[.]",
+     type=".*",
+     ")?"),
+   Elapsed=list(
+     hours="[0-9]+", as.integer,
+     ":",
+     minutes="[0-9]+", as.integer,
+     ":",
+     seconds="[0-9]+", as.integer)))
    Elapsed              JobID JobID.job JobID.task JobID.task1 JobID.taskN
1: 07:04:42        13937810_25  13937810         25          NA          NA
2: 07:04:42  13937810_25.batch  13937810         25          NA          NA
3: 07:04:49 13937810_25.extern  13937810         25          NA          NA
4: 00:00:00     14022192_[1-3]  14022192         NA           1           3
5: 00:00:00       14022204_[4]  14022204         NA           4          NA
   JobID.type Elapsed.hours Elapsed.minutes Elapsed.seconds
1:                        7               4              42
2:      batch             7               4              42
3:     extern             7               4              49
4:                        0               0               0
5:                        0               0               0
> task.dt[, minutes := Elapsed.hours*60+Elapsed.minutes+Elapsed.seconds/60 ]
> task.dt[100 < minutes]
    Elapsed              JobID JobID.job JobID.task JobID.task1 JobID.taskN
1: 07:04:42        13937810_25  13937810         25          NA          NA
2: 07:04:42  13937810_25.batch  13937810         25          NA          NA
3: 07:04:49 13937810_25.extern  13937810         25          NA          NA
   JobID.type Elapsed.hours Elapsed.minutes Elapsed.seconds  minutes
1:                        7               4              42 424.7000
2:      batch             7               4              42 424.7000
3:     extern             7               4              49 424.8167
> 
#+END_SRC

The demo R code that you can paste into your terminal is below.

#+BEGIN_SRC R
  ## Define some sub-patterns separately for clarity.
  range.pattern <- list(
    "[[]",
    task1="[0-9]+", as.integer,
    "(?:-",#begin optional end of range.
    taskN="[0-9]+", as.integer,
    ")?", #end is optional.
    "[]]")
  task.pattern <- list(
    "(?:",#begin alternate
    task="[0-9]+", as.integer,
    "|",#either one task(above) or range(below)
    range.pattern,
    ")")#end alternate

  ## Using df_match_variable with a data.frame
  (sacct.df <- data.frame(
    Elapsed = c(
      "07:04:42", "07:04:42", "07:04:49",
      "00:00:00", "00:00:00"),
    JobID=c(
      "13937810_25",
      "13937810_25.batch",
      "13937810_25.extern",
      "14022192_[1-3]",
      "14022204_[4]"),
    stringsAsFactors=FALSE))
  (task.df <- df_match_variable(
    sacct.df,
    JobID=list(
      job="[0-9]+", as.integer,
      "_",
      task.pattern,
      "(?:[.]",
      type=".*",
      ")?"),
    Elapsed=list(
      hours="[0-9]+", as.integer,
      ":",
      minutes="[0-9]+", as.integer,
      ":",
      seconds="[0-9]+", as.integer)))
  library(dplyr)
  task.df %>%
    transform(minutes=Elapsed.hours*60+Elapsed.minutes+Elapsed.seconds/60) %>%
    filter(100 < minutes)

  ## Using df_match_variable with a data.table
  library(data.table)
  (sacct.dt <- data.table(
    Elapsed = c(
      "07:04:42", "07:04:42", "07:04:49",
      "00:00:00", "00:00:00"),
    JobID=c(
      "13937810_25",
      "13937810_25.batch",
      "13937810_25.extern",
      "14022192_[1-3]",
      "14022204_[4]")))
  (task.dt <- df_match_variable(
    sacct.dt,
    JobID=list(
      job="[0-9]+", as.integer,
      "_",
      task.pattern,
      "(?:[.]",
      type=".*",
      ")?"),
    Elapsed=list(
      hours="[0-9]+", as.integer,
      ":",
      minutes="[0-9]+", as.integer,
      ":",
      seconds="[0-9]+", as.integer)))
  task.dt[, minutes := Elapsed.hours*60+Elapsed.minutes+Elapsed.seconds/60 ]
  task.dt[100 < minutes]
#+END_SRC

*** Set row names using "name" group

The example below illustrates some other features of namedCapture
functions:
- if the subject character vector has names, they will be used to name
  the output (rownames for =str_match_named= and list names for
  =str_match_all_named=).
- if the pattern has a group named =name=, then it will be used for
  the rownames of the output. (if the subject names were not used)
- if no type conversion functions are provided, =str_= functions
  return character matrices. (instead of data.frame)

#+BEGIN_SRC R
  ## If there is a capture group named "name" then it will be used for
  ## the rownames of the result.
  name.value.vec <- c(
    H3K27me3="  sampleType=monocyte   assayType=H3K27me3    cost=5",
    H3K27ac="sampleType=monocyte assayType=H3K27ac",
    H3K4me3=" sampleType=Myeloidcell cost=30.5  assayType=H3K4me3")
  name.value.pattern <- paste0(
    "(?<name>[^ ]+?)",
    "=",
    "(?<value>[^ ]+)")
  (match.list <- str_match_all_named(name.value.vec, name.value.pattern))
  match.list$H3K4me3["cost",]
#+END_SRC

The code/output below illustrates the usage of =str_match_all_named=
with a named subject, which results in list with the same names. Each
element is a character matrix with rownames defined by the =name= capture
group, so it is easy to select the captured text by name.

#+BEGIN_SRC R-transcript
> name.value.vec <- c(
+   H3K27me3="  sampleType=monocyte   assayType=H3K27me3    cost=5",
+   H3K27ac="sampleType=monocyte assayType=H3K27ac",
+   H3K4me3=" sampleType=Myeloidcell cost=30.5  assayType=H3K4me3")
> name.value.pattern <- paste0(
+   "(?<name>[^ ]+?)",
+   "=",
+   "(?<value>[^ ]+)")
> (match.list <- str_match_all_named(name.value.vec, name.value.pattern))
$H3K27me3
           value     
sampleType "monocyte"
assayType  "H3K27me3"
cost       "5"       

$H3K27ac
           value     
sampleType "monocyte"
assayType  "H3K27ac" 

$H3K4me3
           value        
sampleType "Myeloidcell"
cost       "30.5"       
assayType  "H3K4me3"    

> match.list$H3K4me3["cost",]
[1] "30.5"
> 
#+END_SRC

The =df_match_variable= function also sets the rownames of the
resulting data.frame based on the capture group named =name=:

#+BEGIN_SRC R-transcript
> (match.df <- df_match_variable(
+   pos.df,
+   position=list(
+     name="chr.*?",
+     ":",
+     chromStart=".*?", to.int,
+     "-",
+     chromEnd="[0-9,]*", to.int),
+   Elapsed=list(
+     hours="[0-9]+", as.integer,
+     ":",
+     minutes="[0-9]+", as.integer,
+     ":",
+     seconds="[0-9]+", as.integer)))
                           position  Elapsed position.chromStart
chr10 chr10:213,054,000-213,055,000 07:04:42           213054000
chrNA         chrNA:111,000-222,000 07:04:42              111000
chr2                       chr2:1-2 07:04:49                   1
chr3                       chr3:4-5 00:00:00                   4
chr1      chr1:110-111 chr2:220-222 00:00:00                 110
      position.chromEnd Elapsed.hours Elapsed.minutes Elapsed.seconds
chr10         213055000             7               4              42
chrNA            222000             7               4              42
chr2                  2             7               4              49
chr3                  5             0               0               0
chr1                111             0               0               0
> 
#+END_SRC

The demo code you can paste into your R terminal is below:

#+BEGIN_SRC R
  pos.df <- data.frame(
    position=c(
      "chr10:213,054,000-213,055,000",
      "chrNA:111,000-222,000",
      "chr2:1-2",
      "chr3:4-5",
      "chr1:110-111 chr2:220-222"),
    Elapsed = c(
      "07:04:42", "07:04:42", "07:04:49",
      "00:00:00", "00:00:00"),
    stringsAsFactors=FALSE)
  (match.df <- df_match_variable(
    pos.df,
    position=list(
      name="chr.*?",
      ":",
      chromStart=".*?", to.int,
      "-",
      chromEnd="[0-9,]*", to.int),
    Elapsed=list(
      hours="[0-9]+", as.integer,
      ":",
      minutes="[0-9]+", as.integer,
      ":",
      seconds="[0-9]+", as.integer)))
#+END_SRC


** Comparison with rex

In this section we compare namedCapture verbose variable argument
syntax with the similar rex package. We have translated the rex log
parsing example to namedCapture syntax. There are two major
differences in syntax:
- namedCapture assumes the user knows regular expressions and can
  write them in R code; rex assumes the user knows its functions,
  which generate regex strings. E.g. the capture group "time",
  =none_of("[") %>% zero_or_more()= in rex gets translated to the
  regex string =[^]]*=. Thus rex code is a bit more verbose than
  namedCapture.
- Type conversion functions. In namedCapture they are specified on the
  same line as the capture group name/pattern, whereas in rex they are
  specified after the pattern, using mutate. rex could support inline
  type conversion by adding an argument to the =capture= function.

#+BEGIN_SRC R
  subject <- '198.214.42.14 - - [21/Jul/1995:14:31:46 -0400] "GET /images/ HTTP/1.0" 200 17688
  lahal.ksc.nasa.gov - - [24/Jul/1995:12:42:40 -0400] "GET /images/USA-logosmall.gif HTTP/1.0" 200 234
  199.171.112.23 - - [02/Jul/1995:02:30:34 -0400] "GET /images/KSC-logosmall.gif HTTP/1.0" 200 1204
  gate3.fmr.com - - [05/Jul/1995:13:51:39 -0400] "GET /shuttle/countdown/ HTTP/1.0" 200 3985
  curly02.slip.yorku.ca - - [10/Jul/1995:23:11:49 -0400] "GET /shuttle/missions/sts-70/sts-70-patch-small.gif HTTP/1.0" 200 5026
  boson.epita.fr - - [15/Jul/1995:11:27:49 -0400] "GET /shuttle/missions/sts-71/movies/sts-71-mir-dock.mpg HTTP/1.0" 200 946425
  134.153.50.9 - - [13/Jul/1995:11:02:50 -0400] "GET /icons/text.xbm HTTP/1.0" 200 527
  port00.ventura.rain.org - - [23/Jul/1995:09:11:06 -0400] "GET /shuttle/countdown/ HTTP/1.0" 200 4324
  128.159.145.91 - - [14/Jul/1995:10:38:04 -0400] "GET /statistics/images/getstats_big.gif HTTP/1.0" 200 6777
  slo.eei.upmc.edu - - [25/Jul/1995:09:33:01 -0400] "GET /images/KSC-logosmall.gif HTTP/1.0" 200 1204
  206.13.med.umich.edu - - [14/Jul/1995:09:11:28 -0400] "GET /shuttle/resources/orbiters/challenger-logo.gif HTTP/1.0" 200 4179'
  subject.vec <- strsplit(subject, split="\n")[[1]]

  result.list <- list()

  ## namedCapture 10 lines
  result.list$namedCapture <- namedCapture::str_match_variable(
    subject.vec,
    "\\[",
    time="[^]]*", function(x)as.POSIXct(x, format="%d/%b/%Y:%H:%M:%S %z"),
    "\\]",
    ' "GET ',
    "(?:",#maybe
    "[^[:space:]]+[.]",
    filetype='[^[:space:].?"]+', tolower,
    ")?")

  ## rex 17 lines
  library(rex)
  library(dplyr)
  result.list$rex <- re_matches(
    subject.vec,
    rex(
      "[",
      capture(name = "time",
	      none_of("]") %>% zero_or_more()),
      "]",
      space, double_quote, "GET", space,
      maybe(
	non_spaces, ".",
	capture(name = 'filetype',
		none_of(space, ".", "?", double_quote) %>% one_or_more())
      )
    )
  ) %>%
    mutate(filetype = tolower(filetype),
	   time = as.POSIXct(time, format="%d/%b/%Y:%H:%M:%S %z"))

  with(result.list, identical(rex, namedCapture))
#+END_SRC

** Comparison with tidyr

Below I show comparisons between =namedCapture::df_match_variable= and
its closest cousin in the R package universe, =tidyr::extract=. The
two packages can be used to compute the same result, but the
code/syntax is different.

*** Longer more readable syntax 

In this first comparison we use a syntax with each group name on the
same line as its pattern. Here are some observations from the
comparison:
- The =namedCapture= code is shorter. The =tidyr= code is longer
  mostly because the for loop that you see below for =tidyr= is hidden
  inside the definition of =namedCapture::df_match_variable=.
- Converting extracted character groups to numeric column types is
  specified via the =convert= argument of =tidyr::extract=, which uses
  =utils::type.convert=. Because =type.convert= does not know how to
  convert strings like =111,000= to integer, we first need to use
  =remove.commas= to create a new data.frame to use as input to
  =tidyr::extract=. In contrast =namedCapture= supports arbitrary
  group-specific type conversion functions; we specify =to.int= on the
  same line as the corresponding name/pattern for the
  chromStart/chromEnd groups.

#+BEGIN_SRC R
  ## First define data.
  (sacct.df <- data.frame(
    position=c(
      "chr10:213,054,000-213,055,000",
      "chrM:111,000-222,000",
      "this will not match",
      NA, # neither will this.
      "chr1:110-111 chr2:220-222"), # two possible matches.
    JobID=c(
      "13937810_25",
      "13937810_25.batch",
      "13937810_25.extern",
      "14022192_[1-3]",
      "14022204_[4]"),
    stringsAsFactors=FALSE))
  remove.commas <- function(x)gsub(",", "", x)
  result.list <- list()

  ## namedCapture: 29 lines of code.
  range.list <- list(
    "\\[",
    task1="[0-9]+", as.integer,
    "(?:-",#begin optional end of range.
    taskN="[0-9]+", as.integer,
    ")?", #end is optional.
    "\\]")
  task.list <- list(
    "(?:",#begin alternate
    task="[0-9]+", as.integer,
    "|",#either one task(above) or range(below)
    range.list,
    ")")#end alternate
  to.int <- function(x)as.integer(remove.commas(x))
  (result.list$namedCapture <- namedCapture::df_match_variable(
    sacct.df,
    JobID=list(
      job="[0-9]+", as.integer,
      "_",
      task.list,
      "(?:[.]",
      type=".*",
      ")?"),
    position=list(
      chrom="chr.*?",
      ":",
      chromStart=".*?", to.int,
      "-",
      chromEnd="[0-9,]*", to.int)))

  ## tidyr: 46 lines of code.
  range.vec <- c(
    "\\[",
    task1="[0-9]+", 
    "(?:-",#begin optional end of range.
    taskN="[0-9]+", 
    ")?", #end is optional.
    "\\]")
  task.vec <- c(
    "(?:",#begin alternate
    task="[0-9]+", 
    "|",#either one task(above) or range(below)
    range.vec,
    ")")#end alternate
  regex.list <- list(
    JobID=c(
      job="[0-9]+", 
      "_",
      task.vec,
      "(?:[.]",
      type=".*",
      ")?"),
    position=c(
      chrom="chr.*?",
      ":",
      chromStart=".*?",
      "-",
      chromEnd="[0-9,]*"))
  tidyr.input <- transform(
    sacct.df,
    position=remove.commas(position))
  tidyr.df.list <- list(sacct.df)
  for(col.name in names(regex.list)){
    regex.vec <- regex.list[[col.name]]
    is.group <- names(regex.vec)!=""
    format.vec <- ifelse(is.group, "(%s)", "%s")
    group.vec <- sprintf(format.vec, regex.vec)
    regex <- paste(group.vec, collapse="")
    group.names <- names(regex.vec)[is.group]
    result <- tidyr::extract(
      tidyr.input, col.name, group.names, regex, convert=TRUE)
    to.save <- result[, group.names, drop=FALSE]
    names(to.save) <- paste0(col.name, ".", group.names)
    tidyr.df.list[[col.name]] <- to.save
  }
  names(tidyr.df.list) <- NULL
  result.list$tidyr <- do.call(cbind, tidyr.df.list)

  ## Make sure the results are the same.
  t(sapply(result.list, names))
  t(sapply(result.list, sapply, class))
  result.list$tidyr$JobID.type <- ifelse(
    is.na(result.list$tidyr$JobID.type),
    "",
    result.list$tidyr$JobID.type)
  with(result.list, identical(tidyr, namedCapture))

#+END_SRC

*** Shorter less readable syntax

This second comparison uses a syntax with the entire regex on one
line. In my opinion this syntax makes the regular expressions more
difficult to read/understand. Complicated regular expressions like the
one used for matching the JobID column are not
maintainable/understandable at all using this syntax.

#+BEGIN_SRC R
  ## First define data.
  (sacct.df <- data.frame(
    position=c(
      "chr10:213,054,000-213,055,000",
      "chrM:111,000-222,000",
      "this will not match",
      NA, # neither will this.
      "chr1:110-111 chr2:220-222"), # two possible matches.
    JobID=c(
      "13937810_25",
      "13937810_25.batch",
      "13937810_25.extern",
      "14022192_[1-3]",
      "14022204_[4]"),
    stringsAsFactors=FALSE))
  result.list <- list()

  ## tidyr alternate (13 lines total)
  e <- function(col.name, group.names, pattern){
    result <- tidyr::extract(
      sacct.df, col.name, group.names, pattern, convert=TRUE)
    to.save <- result[, group.names, drop=FALSE]
    names(to.save) <- paste0(col.name, ".", group.names)
    to.save
  }
  result.list$tidyr <- do.call(cbind, list(
    sacct.df,
    e("JobID", c("job", "task", "task1", "taskN", "type"),
      "([0-9]+)_(?:([0-9]+)|\\[([0-9]+)(?:-([0-9]+))?\\])(?:[.](.*))?"),
    e("position", c("chrom", "chromStart", "chromEnd"),
      "(chr.*?):(.*?)-([0-9,]*)")))

  ## namedCapture alternate (7 lines total)
  (result.list$namedCapture <- namedCapture::df_match_variable(
    sacct.df,
    JobID="(?<job>[0-9]+)_(?:(?<task>[0-9]+)|\\[(?<task1>[0-9]+)(?:-(?<taskN>[0-9]+))?\\])(?:[.](?<type>.*))?",
    position="(?<chrom>chr.*?):(?<chromStart>.*?)-(?<chromEnd>[0-9,]*)"))
  for(N in names(result.list$namedCapture)){
    result.list$namedCapture[[N]] <- type.convert(result.list$namedCapture[[N]], as.is=TRUE)
  }

  ## Make sure the results are the same.
  t(sapply(result.list, names))
  t(sapply(result.list, sapply, class))
  result.list$tidyr$JobID.type <- ifelse(
    is.na(result.list$tidyr$JobID.type),
    "",
    result.list$tidyr$JobID.type)
  with(result.list, identical(tidyr, namedCapture))
#+END_SRC

** Named capture regular expressions tutorial

For a more complete introduction to named capture regular expressions
in R and Python, see https://github.com/tdhock/regex-tutorial
