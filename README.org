An R package for named capture regular expressions

| [[file:tests/testthat][tests]]    | [[https://travis-ci.org/tdhock/namedCapture][https://travis-ci.org/tdhock/namedCapture.png?branch=master]]                           |
| [[https://github.com/jimhester/covr][coverage]] | [[https://coveralls.io/github/tdhock/namedCapture?branch=master][https://coveralls.io/repos/tdhock/namedCapture/badge.svg?branch=master&service=github]] |

Since R-2.14 (released in 2011), the base functions =regexpr= and
=gregexpr= support named capture regular expressions via the excellent
Perl-Compatible Regular Expressions (PCRE) C library. However their
output is a bunch of integers and group names, which is not very
user-friendly. The namedCapture packages provides user-friendly
functions for extracting data from text using named capture regular
expressions. 

** Related work

- =regexec= and =regmatches= in base R implement extracting capture
  groups but the =regexec= man page indicates that perl=TRUE (and thus
  named capture) is not implemented.
- from R-3.4.0, =utils::strcapture= is an alternative to
  =namedCapture::str_match_named= (extract first match from each
  subject), but there is still no alternative for
  =namedCapture::str_match_all_named= (extract all matches from each
  subject).
- =stringr::str_match= implements extracting capture groups. But since
  it uses the [[https://github.com/gagolews/stringi][stringi]] package (an interface to the [[http://userguide.icu-project.org/strings/regexp][ICU]] library), [[https://github.com/hadley/stringr/pull/16][it
  does not support named capture]].
- [[https://github.com/MangoTheCat/rematch2][rematch2::re_match]], [[https://github.com/kevinushey/rex][rex::re_matches]], and [[https://github.com/qinwf/re2r][re2r::re2_match]] provide similar functionality
  to =namedCapture::str_match_named=. The main difference is that re2r
  uses the RE2 C++ library (worse case polynomial time complexity),
  but rematch2 and namedCapture use base R (PCRE C library, exponential
  worst case time complexity).
- [[https://tidyr.tidyverse.org/reference/separate.html][tidyr::separate]] and [[https://tidyr.tidyverse.org/reference/extract.html][tidyr::extract]] provide similar functionality to
  =namedCapture::df_match_variable= (all input data.frame to extract
  from, and output data.frame). However there are a few differences:
  - named capture groups are supported in =df_match_variable= but not in =tidyr=.
  - namedCapture is much easier to install (it has no compiled code,
    and does not depend on any other packages).
  - A single call to =separate= or =extract= outputs new data columns
    from a single input data column, whereas a single call to
    =df_match_variable= can output new data columns from multiple
    input data columns.
  - regex is used in =separate= for the group separator, whereas regex
    is used in =df_match_variable= and =extract= for the entire text
    (including groups).
  - group names are specified using the =into= argument of =separate=
    and =extract=, whereas group names are specified using R argument
    names / capture group names in =df_match_variable=.
  - =type.convert(as.is=TRUE)= is always used to define types in
    =separate= and =extract=, whereas any function can be used to
    define types in =df_match_variable=.
- [[https://github.com/kevinushey/rex][rex]] provides functions (a domain specific language) for verbosely defining named capture regular expressions in R code. In rex 
  rex(capture(name = "fruit", pattern)) is the analog of list(fruit=pattern) namedCapture::*_variable -- both will generate a capture group named fruit.
  
- [[https://github.com/tdhock/revector][revector]] provides fast C code for a
  *vector* of named capture regular expressions (namedCapture and base
  R and only provide functions for a single regular expression).

** Installation

#+BEGIN_SRC R
if(!require(devtools))install.packages("devtools")
devtools::install_github("tdhock/namedCapture")
#+END_SRC

** Usage examples

There are five main functions provided in namedCapture:

|                             | Extract first match  | Extract each match       |
| chr subject + two arguments | =str_match_named=    | =str_match_all_named=    |
| chr subject + variable args | =str_match_variable= | =str_match_all_variable= |
| df subject + variable args  | =df_match_variable=  | Not implemented          |

The function prefix indicates the type of the first argument, which
must contain the subject:
- =str_*= means a character vector -- each of these functions uses a
  single named capture regular expression to extract data from a
  character vector subject.
- =df_*= means a data.frame -- the [[#tidy-variable-argument-syntax-for-dataframedatatable][df_match_variable]] function uses a
  different named capture regular expression to extract data from each
  of several specified character column subjects. 
The function suffix indicates the type of the other arguments (after
the first):
- =*_named= means three arguments: subject, pattern, functions. The
  pattern should be a length-1 character vector that contains named
  capture groups, e.g. "(?<groupName1>subPattern1)"
- =*_variable= means a variable number of arguments which can be list,
  character, or function. Character strings are interpreted as regular
  expressions, which pasted together to obtain the final pattern to
  match to the subjects. Usually the specified character strings
  should NOT contain named capture groups, because a named capture
  group is generated automatically using R argument names, e.g. the
  argument groupName1="subPattern1" will generate the regex
  "(?<groupName1>subPattern1)". Each function is used to convert the
  group specified by the previous named R argument. Lists are parsed
  recursively, so can contain other lists, functions, and (named) character
  strings.

*** Three argument syntax

The functions on the first row take exactly three arguments:
- =subject= is the character vector from which we want to extract
  tabular data.
- =pattern= is the (character scalar) regular expression with named
  capture groups used for extraction.
- =fun.list= is a list with names that correspond to capture groups,
  and values are functions used to convert the extracted character
  data to other (typically numeric) types.

#+BEGIN_SRC R
  library(namedCapture)
  chr.pos.vec <- c(
    "chr10:213,054,000-213,055,000",
    "chrM:111,000-222,000",
    "this will not match",
    NA, # neither will this.
    "chr1:110-111 chr2:220-222") # two possible matches.
  chr.pos.pattern <- paste0(
    "(?<chrom>chr.*?)",
    ":",
    "(?<chromStart>.*?)",
    "-",
    "(?<chromEnd>[0-9,]*)")
  ## Specifying a list of conversion functions means that str_match_*
  ## should convert the matched groups from character to whatever is
  ## returned by those functions.
  keep.digits <- function(x)as.integer(gsub("[^0-9]", "", x))
  conversion.list <- list(chromStart=keep.digits, chromEnd=keep.digits)
  (match.df <- str_match_named(chr.pos.vec, chr.pos.pattern, conversion.list))
  str(match.df)

  ## Use str_match_all_named to get ALL matches in each subject (not
  ## just the first match).
  str_match_all_named(chr.pos.vec, chr.pos.pattern, conversion.list)
#+END_SRC

Running the =str_match_named= code above yields the following. Note
how the resulting data.frame contains one row for each subject, and
one column for each named capture group defined in the regular
expression pattern. Types are defined by the specified conversion
functions; missing values indicate missing subjects or no match.

#+BEGIN_SRC R-transcript
> (match.df <- str_match_named(chr.pos.vec, chr.pos.pattern, conversion.list))
  chrom chromStart  chromEnd
1 chr10  213054000 213055000
2  chrM     111000    222000
3  <NA>         NA        NA
4  <NA>         NA        NA
5  chr1        110       111
> str(match.df)
'data.frame':	5 obs. of  3 variables:
 $ chrom     : chr  "chr10" "chrM" NA NA ...
 $ chromStart: int  213054000 111000 NA NA 110
 $ chromEnd  : int  213055000 222000 NA NA 111
> 
#+END_SRC

As shown below, running the =str_match_all_named= code extracts all
matches from each subject. The result is a list with one element for
each subject. Each list element is a data.frame with one row for each
match.

#+BEGIN_SRC R-transcript
> str_match_all_named(chr.pos.vec, chr.pos.pattern, conversion.list)
[[1]]
  chrom chromStart  chromEnd
1 chr10  213054000 213055000

[[2]]
  chrom chromStart chromEnd
1  chrM     111000   222000

[[3]]
data frame with 0 columns and 0 rows

[[4]]
data frame with 0 columns and 0 rows

[[5]]
  chrom chromStart chromEnd
1  chr1        110      111
2  chr2        220      222

> 
#+END_SRC

*** Variable argument syntax for character vector subjects

The namedCapture package also provides =str_match*variable= functions
which take a variable number of arguments and allow for a shorter,
less repetitive, and thus more user-friendly syntax:
- The first argument must be the subject character vector.
- The other arguments must be patterns (character strings) or
  functions.
- If a pattern is named, we use the argument name in R for the capture
  group name in the regex.
- All patterns are pasted together in the order that they appear in
  the argument list.
- Each function is used to convert the text extracted by the previous
  named pattern/group. 

#+BEGIN_SRC R
  str_match_variable(
    chr.pos.vec, 
    chrom="chr.*?",
    ":",
    chromStart=".*?", keep.digits,
    "-",
    chromEnd="[0-9,]*", keep.digits)
  str_match_all_variable(
    chr.pos.vec, 
    chrom="chr.*?",
    ":",
    chromStart=".*?", keep.digits,
    "-",
    chromEnd="[0-9,]*", keep.digits)
#+END_SRC

Note in the code above how the group name, regex pattern, and
corresponding type conversion function are all on the same line --
this is encouraged in order to clarify/simplify the definition of
complex regular expressions.

The =str_match_variable= code below yields the same result as the
=str_match_named= code in the previous section: a data.frame with one
row for each subject, and one column for each named capture group.

#+BEGIN_SRC R-transcript
> str_match_variable(
+   chr.pos.vec, 
+   chrom="chr.*?",
+   ":",
+   chromStart=".*?", keep.digits,
+   "-",
+   chromEnd="[0-9,]*", keep.digits)
  chrom chromStart  chromEnd
1 chr10  213054000 213055000
2  chrM     111000    222000
3  <NA>         NA        NA
4  <NA>         NA        NA
5  chr1        110       111
> 
#+END_SRC

The =str_match_all_variable= code below yields a data.frame with one
row for each match in the subject, and one column for each named
capture group. Note that multiple elements in the subject are treated
as separate lines -- internally paste(,collapse="\n") is called to
create a length-1 character vector which is used as the subject in
=str_match_all_named=. This is for the common case of doing readLines
and then extracting all matches of a certain regex in that file. 

#+BEGIN_SRC R-transcript
> str_match_all_variable(
+   chr.pos.vec, 
+   chrom="chr.*?",
+   ":",
+   chromStart=".*?", keep.digits,
+   "-",
+   chromEnd="[0-9,]*", keep.digits)
  chrom chromStart  chromEnd
1 chr10  213054000 213055000
2  chrM     111000    222000
3  chr1        110       111
4  chr2        220       222
> 
#+END_SRC

Finally, sometimes it is simpler/clearer to define complicated
patterns in terms of previously defined sub-patterns. Therefore the
*_variable functions also accept lists as arguments. (which are parsed
recursively) For example, consider the following code block:

#+BEGIN_SRC R
  subject.vec <- c(
    "13937810_25",
    "13937810_25.batch",
    "13937810_25.extern",
    "14022192_[1-3]",
    "14022204_[4]")
  ## range.pattern matches "[4]" or "[1-3]"
  range.pattern <- list(
    "[[]",
    task1="[0-9]+", as.integer,
    "(?:-",#begin optional end of range.
    taskN="[0-9]+", as.integer,
    ")?", #end is optional.
    "[]]")
  ## task.pattern matches "25" or range.pattern.
  task.pattern <- list(
    "(?:",#begin alternate
    task="[0-9]+", as.integer,
    "|",#either one task(above) or range(below)
    range.pattern,
    ")")#end alternate
  (task.dt <- str_match_variable(
    subject.vec,
    job="[0-9]+", as.integer,
    "_",
    task.pattern,
    "(?:[.]",
    type=".*",
    ")?"))
#+END_SRC

The code block starts by defining a sub-pattern which matches =[4]= or
=[1-3]=, and saving it in a variable called =range.pattern=. It is
then used to define a second sub-pattern called =task.pattern= which
matches the above, and alternately matches digits without square
brackets, e.g. =25=. Then finally =task.pattern= is used to
clarify/simplify the call to =str_match_variable=, which yields the
output below.

#+BEGIN_SRC R-transcript
> (task.dt <- str_match_variable(
+   subject.vec,
+   job="[0-9]+", as.integer,
+   "_",
+   task.pattern,
+   "(?:[.]",
+   type=".*",
+   ")?"))
       job task task1 taskN   type
1 13937810   25    NA    NA       
2 13937810   25    NA    NA  batch
3 13937810   25    NA    NA extern
4 14022192   NA     1     3       
5 14022204   NA     4    NA       
> 
#+END_SRC

*** Tidy variable argument syntax for data.frame/data.table

We also provide =namedCapture::df_match_variable= which extracts text
from several columns of a data.frame, using a different named capture
regular expression for each column.
- It requires a data.frame as the first argument.
- It takes a variable number of other arguments. (all of which must be
  named) For each other argument we call =str_match_variable= on one
  column of the input data.frame.
- Each argument name specifies a column of the data.frame which will
  be used as the subject in =str_match_variable=.
- Each argument value specifies a pattern to be used with
  =str_match_variable=. (in list/character/function format as
  explained in the previous section)
- The return value is a data.frame with the same number of rows as the
  input, but with an additional column for each named capture
  group. New columns are named using the convention
  =oldColumnName.groupName=.
- This is a "tidy" function that can be used in a [[https://r4ds.had.co.nz/pipes.html][pipe]].
This function can greatly simplify the code required to create numeric
data columns from character data columns. For example consider the
following data which was output from the [[https://slurm.schedmd.com/sacct.html][sacct]] program.

#+BEGIN_SRC R-transcript
   Elapsed              JobID
1 07:04:42        13937810_25
2 07:04:42  13937810_25.batch
3 07:04:49 13937810_25.extern
4 00:00:00     14022192_[1-3]
5 00:00:00       14022204_[4]
#+END_SRC

Say we want to filter by the total Elapsed time (which is reported as
hours:minutes:seconds), and base job id (which is the number before
the underscore in the JobID column). We could start by converting
those character columns to integers via:

#+BEGIN_SRC R-transcript
> (task.df <- df_match_variable(
+   sacct.df,
+   JobID=list(
+     job="[0-9]+", as.integer,
+     "_",
+     task.pattern,
+     "(?:[.]",
+     type=".*",
+     ")?"),
+   Elapsed=list(
+     hours="[0-9]+", as.integer,
+     ":",
+     minutes="[0-9]+", as.integer,
+     ":",
+     seconds="[0-9]+", as.integer)))
   Elapsed              JobID JobID.job JobID.task JobID.task1 JobID.taskN
1 07:04:42        13937810_25  13937810         25          NA          NA
2 07:04:42  13937810_25.batch  13937810         25          NA          NA
3 07:04:49 13937810_25.extern  13937810         25          NA          NA
4 00:00:00     14022192_[1-3]  14022192         NA           1           3
5 00:00:00       14022204_[4]  14022204         NA           4          NA
  JobID.type Elapsed.hours Elapsed.minutes Elapsed.seconds
1                        7               4              42
2      batch             7               4              42
3     extern             7               4              49
4                        0               0               0
5                        0               0               0
> 
#+END_SRC

We could then create a minutes column and filter on that:

#+BEGIN_SRC R-transcript
> library(dplyr)
> task.df %>%
+   transform(minutes=Elapsed.hours*60+Elapsed.minutes+Elapsed.seconds/60) %>%
+   filter(100 < minutes)
   Elapsed              JobID JobID.job JobID.task JobID.task1 JobID.taskN
1 07:04:42        13937810_25  13937810         25          NA          NA
2 07:04:42  13937810_25.batch  13937810         25          NA          NA
3 07:04:49 13937810_25.extern  13937810         25          NA          NA
  JobID.type Elapsed.hours Elapsed.minutes Elapsed.seconds  minutes
1                        7               4              42 424.7000
2      batch             7               4              42 424.7000
3     extern             7               4              49 424.8167
> 
#+END_SRC

Note that =df_match_variable= also works with data.tables:

#+BEGIN_SRC R-transcript
> library(data.table)
> (sacct.dt <- data.table(
+   Elapsed = c(
+     "07:04:42", "07:04:42", "07:04:49",
+     "00:00:00", "00:00:00"),
+   JobID=c(
+     "13937810_25",
+     "13937810_25.batch",
+     "13937810_25.extern",
+     "14022192_[1-3]",
+     "14022204_[4]")))
    Elapsed              JobID
1: 07:04:42        13937810_25
2: 07:04:42  13937810_25.batch
3: 07:04:49 13937810_25.extern
4: 00:00:00     14022192_[1-3]
5: 00:00:00       14022204_[4]
> (task.dt <- df_match_variable(
+   sacct.dt,
+   JobID=list(
+     job="[0-9]+", as.integer,
+     "_",
+     task.pattern,
+     "(?:[.]",
+     type=".*",
+     ")?"),
+   Elapsed=list(
+     hours="[0-9]+", as.integer,
+     ":",
+     minutes="[0-9]+", as.integer,
+     ":",
+     seconds="[0-9]+", as.integer)))
    Elapsed              JobID JobID.job JobID.task JobID.task1 JobID.taskN
1: 07:04:42        13937810_25  13937810         25          NA          NA
2: 07:04:42  13937810_25.batch  13937810         25          NA          NA
3: 07:04:49 13937810_25.extern  13937810         25          NA          NA
4: 00:00:00     14022192_[1-3]  14022192         NA           1           3
5: 00:00:00       14022204_[4]  14022204         NA           4          NA
   JobID.type Elapsed.hours Elapsed.minutes Elapsed.seconds
1:                        7               4              42
2:      batch             7               4              42
3:     extern             7               4              49
4:                        0               0               0
5:                        0               0               0
> task.dt[, minutes := Elapsed.hours*60+Elapsed.minutes+Elapsed.seconds/60 ]
> task.dt[100 < minutes]
    Elapsed              JobID JobID.job JobID.task JobID.task1 JobID.taskN
1: 07:04:42        13937810_25  13937810         25          NA          NA
2: 07:04:42  13937810_25.batch  13937810         25          NA          NA
3: 07:04:49 13937810_25.extern  13937810         25          NA          NA
   JobID.type Elapsed.hours Elapsed.minutes Elapsed.seconds  minutes
1:                        7               4              42 424.7000
2:      batch             7               4              42 424.7000
3:     extern             7               4              49 424.8167
> 
#+END_SRC

The demo R code that you can paste into your terminal is below.

#+BEGIN_SRC R
  ## Define some sub-patterns separately for clarity.
  range.pattern <- list(
    "[[]",
    task1="[0-9]+", as.integer,
    "(?:-",#begin optional end of range.
    taskN="[0-9]+", as.integer,
    ")?", #end is optional.
    "[]]")
  task.pattern <- list(
    "(?:",#begin alternate
    task="[0-9]+", as.integer,
    "|",#either one task(above) or range(below)
    range.pattern,
    ")")#end alternate

  ## Using df_match_variable with a data.frame
  (sacct.df <- data.frame(
    Elapsed = c(
      "07:04:42", "07:04:42", "07:04:49",
      "00:00:00", "00:00:00"),
    JobID=c(
      "13937810_25",
      "13937810_25.batch",
      "13937810_25.extern",
      "14022192_[1-3]",
      "14022204_[4]"),
    stringsAsFactors=FALSE))
  (task.df <- df_match_variable(
    sacct.df,
    JobID=list(
      job="[0-9]+", as.integer,
      "_",
      task.pattern,
      "(?:[.]",
      type=".*",
      ")?"),
    Elapsed=list(
      hours="[0-9]+", as.integer,
      ":",
      minutes="[0-9]+", as.integer,
      ":",
      seconds="[0-9]+", as.integer)))
  library(dplyr)
  task.df %>%
    transform(minutes=Elapsed.hours*60+Elapsed.minutes+Elapsed.seconds/60) %>%
    filter(100 < minutes)

  ## Using df_match_variable with a data.table
  library(data.table)
  (sacct.dt <- data.table(
    Elapsed = c(
      "07:04:42", "07:04:42", "07:04:49",
      "00:00:00", "00:00:00"),
    JobID=c(
      "13937810_25",
      "13937810_25.batch",
      "13937810_25.extern",
      "14022192_[1-3]",
      "14022204_[4]")))
  (task.dt <- df_match_variable(
    sacct.dt,
    JobID=list(
      job="[0-9]+", as.integer,
      "_",
      task.pattern,
      "(?:[.]",
      type=".*",
      ")?"),
    Elapsed=list(
      hours="[0-9]+", as.integer,
      ":",
      minutes="[0-9]+", as.integer,
      ":",
      seconds="[0-9]+", as.integer)))
  task.dt[, minutes := Elapsed.hours*60+Elapsed.minutes+Elapsed.seconds/60 ]
  task.dt[100 < minutes]
#+END_SRC

*** Set row names using "name" group

The example below illustrates some other features of namedCapture
functions:
- if the subject character vector has names, they will be used to name
  the output (rownames for =str_match_named= and list names for
  =str_match_all_named=).
- if the pattern has a group named =name=, then it will be used for
  the rownames of the output. (if the subject names were not used)
- if no type conversion functions are provided, =str_= functions
  return character matrices. (instead of data.frame)

#+BEGIN_SRC R
  ## If there is a capture group named "name" then it will be used for
  ## the rownames of the result.
  name.value.vec <- c(
    H3K27me3="  sampleType=monocyte   assayType=H3K27me3    cost=5",
    H3K27ac="sampleType=monocyte assayType=H3K27ac",
    H3K4me3=" sampleType=Myeloidcell cost=30.5  assayType=H3K4me3")
  name.value.pattern <- paste0(
    "(?<name>[^ ]+?)",
    "=",
    "(?<value>[^ ]+)")
  (match.list <- str_match_all_named(name.value.vec, name.value.pattern))
  match.list$H3K4me3["cost",]
#+END_SRC

The code/output below illustrates the usage of =str_match_all_named=
with a named subject, which results in list with the same names. Each
element is a character matrix with rownames defined by the =name= capture
group, so it is easy to select the captured text by name.

#+BEGIN_SRC R-transcript
> name.value.vec <- c(
+   H3K27me3="  sampleType=monocyte   assayType=H3K27me3    cost=5",
+   H3K27ac="sampleType=monocyte assayType=H3K27ac",
+   H3K4me3=" sampleType=Myeloidcell cost=30.5  assayType=H3K4me3")
> name.value.pattern <- paste0(
+   "(?<name>[^ ]+?)",
+   "=",
+   "(?<value>[^ ]+)")
> (match.list <- str_match_all_named(name.value.vec, name.value.pattern))
$H3K27me3
           value     
sampleType "monocyte"
assayType  "H3K27me3"
cost       "5"       

$H3K27ac
           value     
sampleType "monocyte"
assayType  "H3K27ac" 

$H3K4me3
           value        
sampleType "Myeloidcell"
cost       "30.5"       
assayType  "H3K4me3"    

> match.list$H3K4me3["cost",]
[1] "30.5"
> 
#+END_SRC

The =df_match_variable= function also sets the rownames of the
resulting data.frame based on the capture group named =name=:

#+BEGIN_SRC R-transcript
> (match.df <- df_match_variable(
+   pos.df,
+   position=list(
+     name="chr.*?",
+     ":",
+     chromStart=".*?", to.int,
+     "-",
+     chromEnd="[0-9,]*", to.int),
+   Elapsed=list(
+     hours="[0-9]+", as.integer,
+     ":",
+     minutes="[0-9]+", as.integer,
+     ":",
+     seconds="[0-9]+", as.integer)))
                           position  Elapsed position.chromStart
chr10 chr10:213,054,000-213,055,000 07:04:42           213054000
chrNA         chrNA:111,000-222,000 07:04:42              111000
chr2                       chr2:1-2 07:04:49                   1
chr3                       chr3:4-5 00:00:00                   4
chr1      chr1:110-111 chr2:220-222 00:00:00                 110
      position.chromEnd Elapsed.hours Elapsed.minutes Elapsed.seconds
chr10         213055000             7               4              42
chrNA            222000             7               4              42
chr2                  2             7               4              49
chr3                  5             0               0               0
chr1                111             0               0               0
> 
#+END_SRC

The demo code you can paste into your R terminal is below:

#+BEGIN_SRC R
  pos.df <- data.frame(
    position=c(
      "chr10:213,054,000-213,055,000",
      "chrNA:111,000-222,000",
      "chr2:1-2",
      "chr3:4-5",
      "chr1:110-111 chr2:220-222"),
    Elapsed = c(
      "07:04:42", "07:04:42", "07:04:49",
      "00:00:00", "00:00:00"),
    stringsAsFactors=FALSE)
  (match.df <- df_match_variable(
    pos.df,
    position=list(
      name="chr.*?",
      ":",
      chromStart=".*?", to.int,
      "-",
      chromEnd="[0-9,]*", to.int),
    Elapsed=list(
      hours="[0-9]+", as.integer,
      ":",
      minutes="[0-9]+", as.integer,
      ":",
      seconds="[0-9]+", as.integer)))
#+END_SRC

** Comparison with other packages

Below I show comparisons between =namedCapture::df_match_variable= and
its closest cousin in the R package universe, =tidyr::extract=. The
two packages can be used to compute the same result, but the
code/syntax is different.

*** Longer more readable syntax 

In this first comparison we use a syntax with each group name on the
same line as its pattern. Here are some observations from the
comparison:
- The =namedCapture= code is shorter. The =tidyr= code is longer
  mostly because the for loop that you see below for =tidyr= is hidden
  inside the definition of =namedCapture::df_match_variable=.
- Converting extracted character groups to numeric column types is
  specified via the =convert= argument of =tidyr::extract=, which uses
  =utils::type.convert=. Because =type.convert= does not know how to
  convert strings like =111,000= to integer, we first need to use
  =remove.commas= to create a new data.frame to use as input to
  =tidyr::extract=. In contrast =namedCapture= supports arbitrary
  group-specific type conversion functions; we specify =to.int= on the
  same line as the corresponding name/pattern for the
  chromStart/chromEnd groups.

#+BEGIN_SRC R
  ## First define data.
  (sacct.df <- data.frame(
    position=c(
      "chr10:213,054,000-213,055,000",
      "chrM:111,000-222,000",
      "this will not match",
      NA, # neither will this.
      "chr1:110-111 chr2:220-222"), # two possible matches.
    JobID=c(
      "13937810_25",
      "13937810_25.batch",
      "13937810_25.extern",
      "14022192_[1-3]",
      "14022204_[4]"),
    stringsAsFactors=FALSE))
  remove.commas <- function(x)gsub(",", "", x)
  result.list <- list()

  ## namedCapture: 29 lines of code.
  range.list <- list(
    "\\[",
    task1="[0-9]+", as.integer,
    "(?:-",#begin optional end of range.
    taskN="[0-9]+", as.integer,
    ")?", #end is optional.
    "\\]")
  task.list <- list(
    "(?:",#begin alternate
    task="[0-9]+", as.integer,
    "|",#either one task(above) or range(below)
    range.list,
    ")")#end alternate
  to.int <- function(x)as.integer(remove.commas(x))
  (result.list$namedCapture <- namedCapture::df_match_variable(
    sacct.df,
    JobID=list(
      job="[0-9]+", as.integer,
      "_",
      task.list,
      "(?:[.]",
      type=".*",
      ")?"),
    position=list(
      chrom="chr.*?",
      ":",
      chromStart=".*?", to.int,
      "-",
      chromEnd="[0-9,]*", to.int)))

  ## tidyr: 46 lines of code.
  range.vec <- c(
    "\\[",
    task1="[0-9]+", 
    "(?:-",#begin optional end of range.
    taskN="[0-9]+", 
    ")?", #end is optional.
    "\\]")
  task.vec <- c(
    "(?:",#begin alternate
    task="[0-9]+", 
    "|",#either one task(above) or range(below)
    range.vec,
    ")")#end alternate
  regex.list <- list(
    JobID=c(
      job="[0-9]+", 
      "_",
      task.vec,
      "(?:[.]",
      type=".*",
      ")?"),
    position=c(
      chrom="chr.*?",
      ":",
      chromStart=".*?",
      "-",
      chromEnd="[0-9,]*"))
  tidyr.input <- transform(
    sacct.df,
    position=remove.commas(position))
  tidyr.df.list <- list(sacct.df)
  for(col.name in names(regex.list)){
    regex.vec <- regex.list[[col.name]]
    is.group <- names(regex.vec)!=""
    format.vec <- ifelse(is.group, "(%s)", "%s")
    group.vec <- sprintf(format.vec, regex.vec)
    regex <- paste(group.vec, collapse="")
    group.names <- names(regex.vec)[is.group]
    result <- tidyr::extract(
      tidyr.input, col.name, group.names, regex, convert=TRUE)
    to.save <- result[, group.names, drop=FALSE]
    names(to.save) <- paste0(col.name, ".", group.names)
    tidyr.df.list[[col.name]] <- to.save
  }
  names(tidyr.df.list) <- NULL
  result.list$tidyr <- do.call(cbind, tidyr.df.list)

  ## Make sure the results are the same.
  t(sapply(result.list, names))
  t(sapply(result.list, sapply, class))
  result.list$tidyr$JobID.type <- ifelse(
    is.na(result.list$tidyr$JobID.type),
    "",
    result.list$tidyr$JobID.type)
  with(result.list, identical(tidyr, namedCapture))

#+END_SRC

*** Shorter less readable syntax

This second comparison uses a syntax with the entire regex on one
line. In my opinion this syntax makes the regular expressions more
difficult to read/understand. Complicated regular expressions like the
one used for matching the JobID column are not
maintainable/understandable at all using this syntax.

#+BEGIN_SRC R
  ## First define data.
  (sacct.df <- data.frame(
    position=c(
      "chr10:213,054,000-213,055,000",
      "chrM:111,000-222,000",
      "this will not match",
      NA, # neither will this.
      "chr1:110-111 chr2:220-222"), # two possible matches.
    JobID=c(
      "13937810_25",
      "13937810_25.batch",
      "13937810_25.extern",
      "14022192_[1-3]",
      "14022204_[4]"),
    stringsAsFactors=FALSE))
  result.list <- list()

  ## tidyr alternate (13 lines total)
  e <- function(col.name, group.names, pattern){
    result <- tidyr::extract(
      sacct.df, col.name, group.names, pattern, convert=TRUE)
    to.save <- result[, group.names, drop=FALSE]
    names(to.save) <- paste0(col.name, ".", group.names)
    to.save
  }
  result.list$tidyr <- do.call(cbind, list(
    sacct.df,
    e("JobID", c("job", "task", "task1", "taskN", "type"),
      "([0-9]+)_(?:([0-9]+)|\\[([0-9]+)(?:-([0-9]+))?\\])(?:[.](.*))?"),
    e("position", c("chrom", "chromStart", "chromEnd"),
      "(chr.*?):(.*?)-([0-9,]*)")))

  ## namedCapture alternate (7 lines total)
  (result.list$namedCapture <- namedCapture::df_match_variable(
    sacct.df,
    JobID="(?<job>[0-9]+)_(?:(?<task>[0-9]+)|\\[(?<task1>[0-9]+)(?:-(?<taskN>[0-9]+))?\\])(?:[.](?<type>.*))?",
    position="(?<chrom>chr.*?):(?<chromStart>.*?)-(?<chromEnd>[0-9,]*)"))
  for(N in names(result.list$namedCapture)){
    result.list$namedCapture[[N]] <- type.convert(result.list$namedCapture[[N]], as.is=TRUE)
  }

  ## Make sure the results are the same.
  t(sapply(result.list, names))
  t(sapply(result.list, sapply, class))
  result.list$tidyr$JobID.type <- ifelse(
    is.na(result.list$tidyr$JobID.type),
    "",
    result.list$tidyr$JobID.type)
  with(result.list, identical(tidyr, namedCapture))
#+END_SRC

** Named capture regular expressions tutorial

For a more complete introduction to named capture regular expressions
in R and Python, see https://github.com/tdhock/regex-tutorial
