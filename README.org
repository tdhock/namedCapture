An R package for named capture regular expressions

| [[file:tests/testthat][tests]]    | [[https://travis-ci.org/tdhock/namedCapture][https://travis-ci.org/tdhock/namedCapture.png?branch=master]]                           |
| [[https://github.com/jimhester/covr][coverage]] | [[https://coveralls.io/github/tdhock/namedCapture?branch=master][https://coveralls.io/repos/tdhock/namedCapture/badge.svg?branch=master&service=github]] |

Since R-2.14, the base functions =regexpr= and =gregexpr= support
named capture regular expressions via the excellent Perl-Compatible
Regular Expressions (PCRE) C library. However their output is a bunch
of integers and group names, which is not very user-friendly. So I
wrote the [[file:R/str_match.R][str_match_named and str_match_all_named wrappers which
return character matrices or data.frames]], which are much more
useful.

** Related work

- =regexec= and =regmatches= in base R implement extracting capture
  groups but the =regexec= man page indicates that perl=TRUE (and thus
  named capture) is not implemented.
- from R-3.4.0, =utils::strcapture= is a user-friendly alternative to
  =namedCapture::str_match_named= (extract first match from each
  subject), but there is still no alternative for
  =namedCapture::str_match_all_named= (extract all matches from each
  subject).
- =stringr::str_match= implements extracting capture groups. But since
  it uses the stringi package (an interface to the [[http://userguide.icu-project.org/strings/regexp][ICU]] library), [[https://github.com/hadley/stringr/pull/16][it
  does not support named capture]].
- [[https://github.com/MangoTheCat/rematch2][rematch2::re_match]] and [[https://github.com/qinwf/re2r][re2r::re2_match]] provide similar functionality
  to =namedCapture::str_match_named=. The main difference is that re2r
  uses the RE2 C++ library (worse case polynomial time complexity),
  but rematch2 and namedCapture use base R (PCRE C library, exponential
  worst case time complexity).
- https://github.com/tdhock/revector provides fast C code for a
  *vector* of named capture regular expressions (namedCapture and base
  R and only provide functions for a single regular expression).

** Installation

#+BEGIN_SRC R
if(!require(devtools))install.packages("devtools")
devtools::install_github("tdhock/namedCapture")
#+END_SRC

** Usage examples

There are four main functions provided in namedCapture:

|                 | Extract first match     | Extract each match          |
|-----------------+-------------------------+-----------------------------|
| Three arguments | =str_match_named=       | =str_match_all_named=       |
| Variable args   | =str_match_variable= | =str_match_all_variable= |

*** Three argument syntax

The functions on the first row take exactly three arguments:
- =subject= is the character vector from which we want to extract
  tabular data.
- =pattern= is the (character scalar) regular expression with named
  capture groups used for extraction.
- =fun.list= is a list with names that correspond to capture groups,
  and values are functions used to convert the extracted character
  data to other (typically numeric) types.

#+BEGIN_SRC R
  library(namedCapture)
  chr.pos.vec <- c(
    "chr10:213,054,000-213,055,000",
    "chrM:111,000-222,000",
    "this will not match",
    NA, # neither will this.
    "chr1:110-111 chr2:220-222") # two possible matches.
  chr.pos.pattern <- paste0(
    "(?<chrom>chr.*?)",
    ":",
    "(?<chromStart>.*?)",
    "-",
    "(?<chromEnd>[0-9,]*)")
  ## Specifying a list of conversion functions means that str_match_*
  ## should convert the matched groups from character to whatever is
  ## returned by those functions.
  keep.digits <- function(x)as.integer(gsub("[^0-9]", "", x))
  conversion.list <- list(chromStart=keep.digits, chromEnd=keep.digits)
  (match.df <- str_match_named(chr.pos.vec, chr.pos.pattern, conversion.list))
  str(match.df)

  ## Use str_match_all_named to get ALL matches in each subject (not
  ## just the first match).
  str_match_all_named(chr.pos.vec, chr.pos.pattern, conversion.list)
#+END_SRC

Running the =str_match_named= code above yields the following. Note
how the resulting data.frame contains one row for each subject, and
one column for each named capture group defined in the regular
expression pattern. Types are defined by the specified conversion
functions; missing values indicate missing subjects or no match.

#+BEGIN_SRC R-transcript
> (match.df <- str_match_named(chr.pos.vec, chr.pos.pattern, conversion.list))
  chrom chromStart  chromEnd
1 chr10  213054000 213055000
2  chrM     111000    222000
3  <NA>         NA        NA
4  <NA>         NA        NA
5  chr1        110       111
> str(match.df)
'data.frame':	5 obs. of  3 variables:
 $ chrom     : chr  "chr10" "chrM" NA NA ...
 $ chromStart: int  213054000 111000 NA NA 110
 $ chromEnd  : int  213055000 222000 NA NA 111
> 
#+END_SRC

As shown below, running the =str_match_all_named= code extracts all
matches from each subject. The result is a list with one element for
each subject. Each list element is a data.frame with one row for each
match.

#+BEGIN_SRC R-transcript
> str_match_all_named(chr.pos.vec, chr.pos.pattern, conversion.list)
[[1]]
  chrom chromStart  chromEnd
1 chr10  213054000 213055000

[[2]]
  chrom chromStart chromEnd
1  chrM     111000   222000

[[3]]
data frame with 0 columns and 0 rows

[[4]]
data frame with 0 columns and 0 rows

[[5]]
  chrom chromStart chromEnd
1  chr1        110      111
2  chr2        220      222

> 
#+END_SRC

*** Variable argument syntax

The namedCapture package also provides =str_match*variable= functions
which take a variable number of arguments and allow for a shorter,
less repetitive, and thus more user-friendly syntax:
- The first argument must be the subject character vector.
- The other arguments must be patterns (character strings) or
  functions.
- If a pattern is named, we use the argument name in R for the capture
  group name in the regex.
- All patterns are pasted together in the order that they appear in
  the argument list.
- Each function is used to convert the text extracted by the previous
  named pattern/group. 

#+BEGIN_SRC R
  str_match_variable(
    chr.pos.vec, 
    chrom="chr.*?",
    ":",
    chromStart=".*?", keep.digits,
    "-",
    chromEnd="[0-9,]*", keep.digits)
  str_match_all_variable(
    chr.pos.vec, 
    chrom="chr.*?",
    ":",
    chromStart=".*?", keep.digits,
    "-",
    chromEnd="[0-9,]*", keep.digits)
#+END_SRC

Note in the code above how the group name, regex pattern, and
corresponding type conversion function are all on the same line --
this is encouraged in order to clarify/simplify the definition of
complex regular expressions.

The =str_match_variable= code below yields the same result as the
=str_match_named= code in the previous section: a data.frame with one
row for each subject, and one column for each named capture group.

#+BEGIN_SRC R-transcript
> str_match_variable(
+   chr.pos.vec, 
+   chrom="chr.*?",
+   ":",
+   chromStart=".*?", keep.digits,
+   "-",
+   chromEnd="[0-9,]*", keep.digits)
  chrom chromStart  chromEnd
1 chr10  213054000 213055000
2  chrM     111000    222000
3  <NA>         NA        NA
4  <NA>         NA        NA
5  chr1        110       111
> 
#+END_SRC

The =str_match_all_variable= code below yields a data.frame with one
row for each match in the subject, and one column for each named
capture group. Note that multiple elements in the subject are treated
as separate lines -- internally paste(,collapse="\n") is called to
create a length-1 character vector which is used as the subject in
=str_match_all_named=. This is for the common case of doing readLines
and then extracting all matches of a certain regex in that file. 

#+BEGIN_SRC R-transcript
> str_match_all_variable(
+   chr.pos.vec, 
+   chrom="chr.*?",
+   ":",
+   chromStart=".*?", keep.digits,
+   "-",
+   chromEnd="[0-9,]*", keep.digits)
  chrom chromStart  chromEnd
1 chr10  213054000 213055000
2  chrM     111000    222000
3  chr1        110       111
4  chr2        220       222
> 
#+END_SRC

Finally, sometimes it is simpler/clearer to define complicated
patterns in terms of previously defined sub-patterns. Therefore the
*_variable functions also accept lists as arguments. (which are parsed
recursively) For example, consider the following code block:

#+BEGIN_SRC R
  subject.vec <- c(
    "13937810_25",
    "13937810_25.batch",
    "13937810_25.extern",
    "14022192_[1-3]",
    "14022204_[4]")
  ## range.pattern matches "25" or "[4]" or "[1-3]"
  range.pattern <- list(
    "[[]",
    task1="[0-9]+", as.integer,
    "(?:-",#begin optional end of range.
    taskN="[0-9]+", as.integer,
    ")?", #end is optional.
    "[]]")
  task.pattern <- list(
    "(?:",#begin alternate
    task="[0-9]+", as.integer,
    "|",#either one task(above) or range(below)
    range.pattern,
    ")")#end alternate
  (task.dt <- str_match_variable(
    subject.vec,
    job="[0-9]+", as.integer,
    "_",
    task.pattern,
    "(?:[.]",
    type=".*",
    ")?"))
#+END_SRC

The code block starts by defining a sub-pattern which matches =[4]= or
=[1-3]=, and saving it in a variable called =range.pattern=. It is
then used to define a second sub-pattern called =task.pattern= which
matches the above, and alternately matches digits without square
brackets, e.g. =25=. Then finally =task.pattern= is used to
clarify/simplify the call to =str_match_variable=, which yields the
output below.

#+BEGIN_SRC R-transcript
> (task.dt <- str_match_variable(
+   subject.vec,
+   job="[0-9]+", as.integer,
+   "_",
+   task.pattern,
+   "(?:[.]",
+   type=".*",
+   ")?"))
       job task task1 taskN   type
1 13937810   25    NA    NA       
2 13937810   25    NA    NA  batch
3 13937810   25    NA    NA extern
4 14022192   NA     1     3       
5 14022204   NA     4    NA       
> 
#+END_SRC

*** Set row names using "name" group

The example below illustrates some other features of namedCapture
functions:
- if the subject character vector has names, they will be used to name
  the output (rownames for =str_match_named= and list names for
  =str_match_all_named=).
- if the pattern has a group named =name=, then it will be used for
  the rownames of the output. (if the subject names were not used)
- if no type conversion functions are provided, return values are
  character matrices. (instead of data.frame)

#+BEGIN_SRC R
  ## If there is a capture group named "name" then it will be used for
  ## the rownames of the result.
  name.value.vec <- c(
    H3K27me3="  sampleType=monocyte   assayType=H3K27me3    cost=5",
    H3K27ac="sampleType=monocyte assayType=H3K27ac",
    H3K4me3=" sampleType=Myeloidcell cost=30.5  assayType=H3K4me3")
  name.value.pattern <- paste0(
    "(?<name>[^ ]+?)",
    "=",
    "(?<value>[^ ]+)")
  (match.list <- str_match_all_named(name.value.vec, name.value.pattern))
  match.list$H3K4me3["cost",]
#+END_SRC

The code/output below illustrates the usage of =str_match_all_named=
with a named subject, which results in list with the same names. Each
element is a character matrix with rownames defined by the =name= capture
group, so it is easy to select the captured text by name.

#+BEGIN_SRC R-transcript
> name.value.vec <- c(
+   H3K27me3="  sampleType=monocyte   assayType=H3K27me3    cost=5",
+   H3K27ac="sampleType=monocyte assayType=H3K27ac",
+   H3K4me3=" sampleType=Myeloidcell cost=30.5  assayType=H3K4me3")
> name.value.pattern <- paste0(
+   "(?<name>[^ ]+?)",
+   "=",
+   "(?<value>[^ ]+)")
> (match.list <- str_match_all_named(name.value.vec, name.value.pattern))
$H3K27me3
           value     
sampleType "monocyte"
assayType  "H3K27me3"
cost       "5"       

$H3K27ac
           value     
sampleType "monocyte"
assayType  "H3K27ac" 

$H3K4me3
           value        
sampleType "Myeloidcell"
cost       "30.5"       
assayType  "H3K4me3"    

> match.list$H3K4me3["cost",]
[1] "30.5"
> 
#+END_SRC

** Named capture regular expressions tutorial

For a more complete introduction to named capture regular expressions
in R and Python, see https://github.com/tdhock/regex-tutorial
